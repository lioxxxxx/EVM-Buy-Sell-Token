import { Pool } from '../pool/Pool';
import type { Address, Cell, Contract, HttpProvider, AddressType, AmountType, MessageData, QueryIdType, ContractOptions } from '../../../types';
import type { RouterGasConstants, RouterRevision } from './RouterRevision';
import { RouterRevisionV1 } from './RouterRevisionV1';
declare const Address: typeof import("tonweb/dist/types/utils/address").Address, Contract: typeof import("tonweb/dist/types/contract/contract").Contract;
declare const REVISIONS: {
    readonly V1: typeof RouterRevisionV1;
};
/**
 * @type {RouterData} containing state of the router
 *
 * @property {boolean} isLocked - true if transfer_notification operations are locked (swap, provide_lp)
 * @property {Address} adminAddress - Address of contract's admin account
 * @property {Cell} tempUpgrade - A structure describing state of contract's code & admin upgrade; zero values indicate that no upgrade is pending
 * @property {Cell} poolCode - Code of the router's liquidity pool contract
 * @property {Cell} jettonLpWalletCode - Code of lp wallet contract
 * @property {Cell} lpAccountCode - Code of lp account contract
 */
export declare type RouterData = {
    isLocked: boolean;
    adminAddress: Address | null;
    tempUpgrade: Cell;
    poolCode: Cell;
    jettonLpWalletCode: Cell;
    lpAccountCode: Cell;
};
interface RouterOptions extends ContractOptions {
    address: AddressType;
    revision: RouterRevision | keyof typeof REVISIONS;
}
/**
 * @type {Router} represents the router contract and provide methods to interact with it.
 *
 * The router is the contract that acts as an entrypoint for all DEX calls.
 * It is responsible for routing all Jetton calls with transfer_notification op to the correct pool contract.
 * It acts as a sovereign over the DEX, and can be used to lock/unlock trading on all pools,
 * to change fees on a certain pool or to upgrade its own contract. The router is the only contract that can be upgraded.
 * Each Jetton that goes through the DEX is owned by the router. The router does not store anything about pairs.
 */
export declare class Router extends Contract {
    private revision;
    constructor(provider: HttpProvider, { revision, ...options }: RouterOptions);
    get gasConstants(): RouterGasConstants;
    /**
     * Create a payload for the `swap` transaction.
     *
     * @param {Address | string} params.userWalletAddress - User's address
     * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)
     * @param {Address | string} params.askJettonWalletAddress - Jetton router's wallet address of tokens to be received
     * @param {Address | string | undefined} params.referralAddress - Optional; referral address
     *
     * @returns {Cell} payload for the `swap` transaction.
     */
    createSwapBody(params: {
        userWalletAddress: AddressType;
        minAskAmount: AmountType;
        askJettonWalletAddress: AddressType;
        referralAddress?: AddressType;
    }): Promise<Cell>;
    /**
     * Create a payload for the `provide_lp` transaction.
     *
     * @param {Address | string} params.routerWalletAddress - Address of the router's Jetton token wallet
     * @param {BN | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)
     *
     * @returns payload for the `provide_lp` transaction.
     */
    createProvideLiquidityBody(params: {
        routerWalletAddress: AddressType;
        minLpOut: AmountType;
    }): Promise<Cell>;
    /**
     * **Note:** It's necessary to specify addresses of Jetton wallets of the router as the arguments of this method.
     * These addresses can be retrieved with getJettonWalletAddress of the Jetton minter.
     * @param {Address | string} params.token0 - The address of the router's wallet of first Jetton
     * @param {Address | string} params.token1 - The address of the router's wallet of second Jetton
     *
     * @returns {Address | null} an address of a pool for a specified pair of assets.
     */
    getPoolAddress(params: {
        token0: AddressType;
        token1: AddressType;
    }): Promise<Address | null>;
    /**
     * @param {[Address | string, Address | string]} params.jettonAddresses - Tuple of Jetton addresses of a pool
     *
     * @returns {Pool} object for a pool with specified Jetton token addresses.
     */
    getPool(params: {
        jettonAddresses: [AddressType, AddressType];
    }): Promise<Pool | null>;
    /**
     * @returns {RouterData} containing current state of the router.
     */
    getData(): Promise<RouterData>;
    /**
     * Build all data required to execute a jetton `swap` transaction
     *
     * @param {Address | string} params.userWalletAddress - User's address
     * @param {Address | string} params.offerJettonAddress - Jetton address of a token to be swapped
     * @param {Address | string} params.askJettonAddress - Jetton address of a token to be received
     * @param {BN | number} params.offerAmount - Amount of tokens to be swapped (in basic token units)
     * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)
     * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)
     * @param {BN | number | undefined} params.forwardGasAmount - Optional; forward amount of gas for the next transaction (in nanoTons)
     * @param {Address | string | undefined} params.referralAddress - Optional; referral address
     * @param {BN | number | undefined} params.queryId - Optional; query id
     *
     * @returns {MessageData} data required to execute a jetton `swap` transaction
     */
    buildSwapJettonTxParams(params: {
        userWalletAddress: AddressType;
        offerJettonAddress: AddressType;
        askJettonAddress: AddressType;
        offerAmount: AmountType;
        minAskAmount: AmountType;
        gasAmount?: AmountType;
        forwardGasAmount?: AmountType;
        referralAddress?: AddressType;
        queryId?: QueryIdType;
    }): Promise<MessageData>;
    /**
     * Build all data required to execute a ton to jetton `swap` transaction
     *
     * @param {Address | string} params.userWalletAddress - User's address
     * @param {Address | string} params.proxyTonAddress - Address of a proxy ton contract
     * @param {Address | string} params.askJettonAddress - Jetton address of a token to be received
     * @param {BN | number} params.offerAmount - Amount of ton to be swapped (in nanoTons)
     * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)
     * @param {BN | number | undefined} params.forwardGasAmount - Optional; forward amount of gas for the next transaction (in nanoTons)
     * @param {Address | string | undefined} params.referralAddress - Optional; referral address
     * @param {BN | number | undefined} params.queryId - Optional; query id
     *
     * @returns {MessageData} data required to execute a ton to jetton `swap` transaction
     */
    buildSwapProxyTonTxParams(params: {
        userWalletAddress: AddressType;
        proxyTonAddress: AddressType;
        askJettonAddress: AddressType;
        offerAmount: AmountType;
        minAskAmount: AmountType;
        forwardGasAmount?: AmountType;
        referralAddress?: AddressType | undefined;
        queryId?: QueryIdType;
    }): Promise<MessageData>;
    /**
     * Collect all data required to execute a jetton `provide_lp` transaction
     *
     * @param {Address | string} params.userWalletAddress - User's address
     * @param {Address | string} params.sendTokenAddress - Address of the provided Jetton token
     * @param {Address | string} params.otherTokenAddress - Address of the other Jetton token in pair
     * @param {BN | number} params.sendAmount - Amount of the first token deposited as liquidity (in basic token units)
     * @param {BN | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)
     * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)
     * @param {BN | number | undefined} params.forwardGasAmount - Optional; forward amount of gas for the next transaction (in nanoTons)
     * @param {BN | number | undefined} params.queryId - Optional; query id
     *
     * @returns {MessageData} data required to execute a jetton `provide_lp` transaction
     */
    buildProvideLiquidityJettonTxParams(params: {
        userWalletAddress: AddressType;
        sendTokenAddress: AddressType;
        otherTokenAddress: AddressType;
        sendAmount: AmountType;
        minLpOut: AmountType;
        gasAmount?: AmountType;
        forwardGasAmount?: AmountType;
        queryId?: QueryIdType;
    }): Promise<MessageData>;
    /**
     * Collect all data required to execute a proxy ton `provide_lp` transaction
     *
     * @param {Address | string} params.userWalletAddress - User's address
     * @param {Address | string} params.proxyTonAddress - Address of a proxy ton contract
     * @param {Address | string} params.otherTokenAddress - Address of the other Jetton token in pair
     * @param {BN | number} params.sendAmount - Amount of ton deposited as liquidity (in nanoTons)
     * @param {BN | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)
     * @param {BN | number | undefined} params.forwardGasAmount - Optional; forward amount of gas for the next transaction (in nanoTons)
     * @param {BN | number | undefined} params.queryId - Optional; query id
     *
     * @returns {MessageData} data required to execute a proxy ton `provide_lp` transaction
     */
    buildProvideLiquidityProxyTonTxParams(params: {
        userWalletAddress: AddressType;
        proxyTonAddress: AddressType;
        otherTokenAddress: AddressType;
        sendAmount: AmountType;
        minLpOut: AmountType;
        forwardGasAmount?: AmountType;
        queryId?: QueryIdType;
    }): Promise<MessageData>;
}
export {};
//# sourceMappingURL=Router.d.ts.map