import { LpAccount } from '../lp-account/LpAccount';
import type { Address, Cell, HttpProvider, JettonMinter, JettonWallet, BN, AddressType, QueryIdType, JettonMinterOptions, MessageData, AmountType } from '../../../types';
import { PoolGasConstants, PoolRevision } from './PoolRevision';
import { PoolRevisionV1 } from './PoolRevisionV1';
declare const Address: typeof import("tonweb/dist/types/utils/address").Address, BN: typeof import("bn.js"), JettonMinter: typeof import("tonweb/dist/types/contract/token/ft/jetton-minter").JettonMinter, JettonWallet: typeof import("tonweb/dist/types/contract/token/ft/jetton-wallet").JettonWallet;
declare const REVISIONS: {
    readonly V1: typeof PoolRevisionV1;
};
/**
 * @type {PoolData} state of the pool: Jetton token reserves, Jetton wallet addresses and fee parameters.
 *
 * @property {BN} reserve0 - Amount of the first token (in basic token units)
 * @property {BN} reserve1 - Amount of the second token (in basic token units)
 * @property {Address | null} token0WalletAddress - Address of the first Jetton token
 * @property {Address | null} token1WalletAddress - Address of the second Jetton token
 * @property {BN} lpFee - Liquidity pool fee value
 * @property {BN} protocolFee - Protocol fee
 * @property {BN} refFee - Referral fee
 * @property {Address | null} protocolFeeAddress - Address for receiving protocol fees
 * @property {BN} collectedToken0ProtocolFee - Amount of collected protocol fees of the first token (in basic token units)
 * @property {BN} collectedToken1ProtocolFee - Amount of collected protocol fees of the second token (in basic token units)
 */
export declare type PoolData = {
    reserve0: BN;
    reserve1: BN;
    token0WalletAddress: Address | null;
    token1WalletAddress: Address | null;
    lpFee: BN;
    protocolFee: BN;
    refFee: BN;
    protocolFeeAddress: Address | null;
    collectedToken0ProtocolFee: BN;
    collectedToken1ProtocolFee: BN;
};
/**
 * @type {ExpectedOutputsData}
 *
 * @property {BN} jettonToReceive - Amount of tokens received (in basic token units)
 * @property {BN} protocolFeePaid - Amount tokens paid for protocol fees (in basic token units)
 * @property {BN} refFeePaid - Amount tokens paid for referral fees (in basic token units)
 */
export declare type ExpectedOutputsData = {
    jettonToReceive: BN;
    protocolFeePaid: BN;
    refFeePaid: BN;
};
/**
 * @type {PoolAmountsData}
 *
 * @property {BN} amount0 - Amount of tokens for the first Jetton (in basic token units)
 * @property {BN} amount1 - Amount of tokens for the second Jetton (in basic token units)
 */
export declare type PoolAmountsData = {
    amount0: BN;
    amount1: BN;
};
interface PoolOptions extends JettonMinterOptions {
    revision: PoolRevision | keyof typeof REVISIONS;
    address: AddressType;
}
/**
 * @type {Pool} represents the pool contract and provide methods to interact with it.
 *
 * The pool is the contract that stores the AMM data for a certain pair and is responsible for handling “swaps” or providing liquidity for a certain pool.
 * For each pair (e.g. WTON/USDT), there is only a single pool contract.
 * The pool is also a Jetton Minter, and handles minting/burning of Liquidity Provider Jettons.
 * All the swap/lp calculations are done in the pool contract.
 */
export declare class Pool extends JettonMinter {
    private revision;
    constructor(provider: HttpProvider, { revision, ...options }: PoolOptions);
    get gasConstants(): PoolGasConstants;
    /**
     * Create a payload for the `collect_fees` transaction.
     *
     * @param {BN | number | undefined} params.queryId - Optional; query id
     *
     * @returns {Cell} payload for the `collect_fees` transaction.
     */
    createCollectFeesBody(params?: {
        queryId?: QueryIdType;
    }): Promise<Cell>;
    /**
     * Create a payload for the `burn` transaction.
     *
     * @param {BN | number} params.amount - Amount of lp tokens to burn (in basic token units)
     * @param {Address | string} params.responseAddress - Address of a user
     * @param {BN | number | undefined} params.queryId - Optional; query id
     *
     * @returns {Cell} payload for the `burn` transaction.
     */
    createBurnBody(params: {
        amount: AmountType;
        responseAddress: AddressType;
        queryId?: QueryIdType;
    }): Promise<Cell>;
    /**
     * Estimate expected result of the amount of jettonWallet tokens swapped to the other type of tokens of the pool
     *
     * @param {BN | number} params.amount - Amount of tokens to swap (in basic token units)
     * @param {Address | string} params.jettonWallet - Token Jetton address (must be equal to one of the Jetton addresses of the pool)
     *
     * @returns {ExpectedOutputsData} structure with expected result of a token swap
     */
    getExpectedOutputs(params: {
        amount: AmountType;
        jettonWallet: AddressType;
    }): Promise<ExpectedOutputsData>;
    /**
     * Estimate an expected amount of lp tokens minted when providing liquidity.
     *
     * @param {BN | number} params.amount0 - Amount of tokens for the first Jetton (in basic token units)
     * @param {BN | number} params.amount1 - Amount of tokens for the second Jetton (in basic token units)
     *
     * @returns {BN} an estimated amount of liquidity tokens to be minted
     */
    getExpectedTokens(params: {
        amount0: AmountType;
        amount1: AmountType;
    }): Promise<BN>;
    /**
     * Estimate expected liquidity freed upon burning liquidity tokens.
     *
     * @param {BN | number} params.jettonAmount - Amount of liquidity tokens (in basic token units)
     *
     * @returns {PoolAmountsData} structure with expected freed liquidity
     */
    getExpectedLiquidity(params: {
        jettonAmount: AmountType;
    }): Promise<PoolAmountsData>;
    /**
     * @param {Address | string} params.ownerAddress - Address of a user
     *
     * @returns a JettonWallet object for an address returned by getJettonWalletAddress
     */
    getJettonWallet(params: {
        ownerAddress: AddressType;
    }): Promise<JettonWallet>;
    /**
     * @param {Address | string} params.ownerAddress - Address of a user
     *
     * @returns the lp account address of a user
     */
    getLpAccountAddress(params: {
        ownerAddress: AddressType;
    }): Promise<Address | null>;
    /**
     * @param {Address | string} params.ownerAddress - Address of a user
     *
     * @returns {LpAccount} object for address returned by getLpAccountAddress
     */
    getLpAccount(params: {
        ownerAddress: AddressType;
    }): Promise<LpAccount | null>;
    /**
     * @returns {PoolData} containing current state of the pool
     */
    getData(): Promise<PoolData>;
    /**
     * Build all data required to execute a `collect_fees` transaction.
     *
     * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)
     * @param {BN | number | undefined} params.queryId - Optional; query id
     *
     * @returns {MessageData} all data required to execute a `collect_fees` transaction.
     */
    buildCollectFeeTxParams(params?: {
        gasAmount?: AmountType;
        queryId?: QueryIdType;
    }): Promise<MessageData>;
    /**
     * Build all data required to execute a `burn` transaction.
     *
     * @param {BN | number} params.amount - Amount of lp tokens to burn (in basic token units)
     * @param {Address | string} params.responseAddress - Address of a user
     * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)
     * @param {BN | number | undefined} params.queryId - Optional; query id
     *
     * @returns {MessageData} all data required to execute a `burn` transaction.
     */
    buildBurnTxParams(params: {
        amount: AmountType;
        responseAddress: AddressType;
        gasAmount?: AmountType;
        queryId?: QueryIdType;
    }): Promise<MessageData>;
}
export {};
//# sourceMappingURL=Pool.d.ts.map