import c from "tonweb";
const g = {
  ADD_LIQUIDITY: 1935855772,
  SWAP: 630424929,
  PROVIDE_LIQUIDITY: 4244235663,
  DIRECT_ADD_LIQUIDITY: 1291331587,
  REFUND: 200537159,
  RESET_GAS: 1117846339,
  COLLECT_FEES: 533429565,
  REQUEST_BURN: 1499400124
}, T = {
  V1: "V1"
}, ht = {
  [T.V1]: "EQB3ncyBUTjZUA5EnFKR5_EnOMI9V1tTEAAPaiU71gc4TiUt"
}, { Address: Y } = c, P = (o, t, s) => {
  let e = BigInt(0);
  for (let n = 0; n < s; n++)
    e *= BigInt(2), e += BigInt(o.get(t + n));
  return e;
}, a = (o) => {
  try {
    let t = P(o.bits, 3, 8);
    t > BigInt(127) && (t = t - BigInt(256));
    const s = P(o.bits, 3 + 8, 256);
    if (t.toString(10) + ":" + s.toString(16) == "0:0")
      return null;
    const e = t.toString(10) + ":" + s.toString(16).padStart(64, "0");
    return new Y(e);
  } catch {
    return null;
  }
}, {
  boc: { Cell: S },
  utils: { BN: y }
} = c;
class Q {
  constructor() {
    this.createRefundBody = async (t, s) => {
      const e = new S();
      return e.bits.writeUint(g.REFUND, 32), e.bits.writeUint((s == null ? void 0 : s.queryId) ?? 0, 64), e;
    }, this.createDirectAddLiquidityBody = async (t, s) => {
      const e = new S();
      return e.bits.writeUint(g.DIRECT_ADD_LIQUIDITY, 32), e.bits.writeUint(s.queryId ?? 0, 64), e.bits.writeCoins(new y(s.amount0)), e.bits.writeCoins(new y(s.amount1)), e.bits.writeCoins(new y(s.minimumLpToMint ?? 1)), e;
    }, this.createResetGasBody = async (t, s) => {
      const e = new S();
      return e.bits.writeUint(g.RESET_GAS, 32), e.bits.writeUint((s == null ? void 0 : s.queryId) ?? 0, 64), e;
    }, this.getData = async (t) => {
      const s = await t.getAddress(), e = await t.provider.call2(
        s.toString(),
        "get_lp_account_data"
      );
      return {
        userAddress: a(e[0]),
        poolAddress: a(e[1]),
        amount0: e[2],
        amount1: e[3]
      };
    };
  }
  get gasConstants() {
    return {
      refund: new y(5e8),
      directAddLp: new y(3e8),
      resetGas: new y(3e8)
    };
  }
}
const {
  Contract: Z,
  utils: { BN: b }
} = c, U = {
  [T.V1]: Q
};
class X extends Z {
  constructor(t, { revision: s, ...e }) {
    if (super(t, e), typeof s == "string") {
      if (!U[s])
        throw Error(`Unknown account revision: ${s}`);
      this.revision = new U[s]();
    } else
      this.revision = s;
  }
  get gasConstants() {
    return this.revision.gasConstants;
  }
  /**
   * Create a payload for the `refund_me` transaction.
   *
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {Cell} payload for the `refund_me` transaction.
   */
  async createRefundBody(t) {
    return this.revision.createRefundBody(this, t);
  }
  /**
   * Create a payload for the `direct_add_liquidity` transaction.
   *
   * @param {BN | number} params.amount0 - Amount of the first Jetton tokens (in basic token units)
   * @param {BN | number} params.amount1 - Amount of the second Jetton tokens (in basic token units)
   * @param {BN | number | undefined} params.minimumLpToMint - Optional; minimum amount of received liquidity tokens (in basic token units)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {Cell} payload for the `direct_add_liquidity` transaction.
   */
  async createDirectAddLiquidityBody(t) {
    return this.revision.createDirectAddLiquidityBody(this, t);
  }
  /**
   * Create a payload for the `reset_gas` transaction.
   *
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {Cell} payload for the `reset_gas` transaction.
   */
  async createResetGasBody(t) {
    return this.revision.createResetGasBody(this, t);
  }
  /**
   * @returns {LpAccountData} structure containing current state of the lp account.
   */
  async getData() {
    return await this.revision.getData(this);
  }
  /**
   * Build all data required to execute a `refund_me` transaction.
   *
   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} all data required to execute a `refund_me` transaction.
   */
  async buildRefundTxParams(t) {
    const s = await this.getAddress(), e = await this.createRefundBody({ queryId: t == null ? void 0 : t.queryId }), n = new b((t == null ? void 0 : t.gasAmount) ?? this.gasConstants.refund);
    return { to: s, payload: e, gasAmount: n };
  }
  /**
   * Build all data required to execute a `direct_add_liquidity` transaction.
   *
   * @param {BN | number} params.amount0 - Amount of the first Jetton tokens (in basic token units)
   * @param {BN | number} params.amount1 - Amount of the second Jetton tokens (in basic token units)
   * @param {BN | number | undefined} params.minimumLpToMint - Optional; minimum amount of received liquidity tokens (in basic token units)
   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} all data required to execute a `direct_add_liquidity` transaction.
   */
  async buildDirectAddLiquidityTxParams(t) {
    const s = await this.getAddress(), e = await this.createDirectAddLiquidityBody({
      amount0: t.amount0,
      amount1: t.amount1,
      minimumLpToMint: t.minimumLpToMint,
      queryId: t.queryId
    }), n = new b(t.gasAmount ?? this.gasConstants.directAddLp);
    return { to: s, payload: e, gasAmount: n };
  }
  /**
   * Build all data required to execute a `reset_gas` transaction.
   *
   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} all data required to execute a `reset_gas` transaction.
   */
  async buildResetGasTxParams(t) {
    const s = await this.getAddress(), e = await this.createResetGasBody({ queryId: t == null ? void 0 : t.queryId }), n = new b((t == null ? void 0 : t.gasAmount) ?? this.gasConstants.resetGas);
    return { to: s, payload: e, gasAmount: n };
  }
}
const {
  utils: { BN: k, bytesToBase64: W },
  boc: { Cell: v },
  Address: R
} = c;
class m {
  constructor() {
    this.createCollectFeesBody = async (t, s) => {
      const e = new v();
      return e.bits.writeUint(g.COLLECT_FEES, 32), e.bits.writeUint((s == null ? void 0 : s.queryId) ?? 0, 64), e;
    }, this.createBurnBody = async (t, s) => {
      const e = new v();
      return e.bits.writeUint(g.REQUEST_BURN, 32), e.bits.writeUint(s.queryId ?? 0, 64), e.bits.writeCoins(new k(s.amount)), e.bits.writeAddress(new R(s.responseAddress)), e;
    }, this.getExpectedOutputs = async (t, s) => {
      const e = new v();
      e.bits.writeAddress(new R(s.jettonWallet));
      const n = W(await e.toBoc(!1)), r = await t.getAddress(), i = await t.provider.call2(
        r.toString(),
        "get_expected_outputs",
        [
          ["int", s.amount.toString()],
          ["tvm.Slice", n]
        ]
      );
      return {
        jettonToReceive: i[0],
        protocolFeePaid: i[1],
        refFeePaid: i[2]
      };
    }, this.getExpectedTokens = async (t, s) => {
      const e = await t.getAddress();
      return await t.provider.call2(
        e.toString(),
        "get_expected_tokens",
        [
          ["int", s.amount0.toString()],
          ["int", s.amount1.toString()]
        ]
      );
    }, this.getExpectedLiquidity = async (t, s) => {
      const e = await t.getAddress(), n = await t.provider.call2(
        e.toString(),
        "get_expected_liquidity",
        [["int", s.jettonAmount.toString()]]
      );
      return {
        amount0: n[0],
        amount1: n[1]
      };
    }, this.getLpAccountAddress = async (t, s) => {
      const e = new v();
      e.bits.writeAddress(new R(s.ownerAddress));
      const n = W(await e.toBoc(!1)), r = await t.getAddress(), i = await t.provider.call2(
        r.toString(),
        "get_lp_account_address",
        [["tvm.Slice", n]]
      );
      return a(i);
    }, this.constructLpAccountRevision = (t) => new Q(), this.getData = async (t) => {
      const s = await t.getAddress(), e = await t.provider.call2(
        s.toString(),
        "get_pool_data"
      );
      return {
        reserve0: e[0],
        reserve1: e[1],
        token0WalletAddress: a(e[2]),
        token1WalletAddress: a(e[3]),
        lpFee: e[4],
        protocolFee: e[5],
        refFee: e[6],
        protocolFeeAddress: a(e[7]),
        collectedToken0ProtocolFee: e[8],
        collectedToken1ProtocolFee: e[9]
      };
    };
  }
  get gasConstants() {
    return {
      collectFees: new k(11e8),
      burn: new k(5e8)
    };
  }
}
const {
  Address: q,
  utils: { BN: L },
  token: {
    jetton: { JettonMinter: z, JettonWallet: H }
  }
} = c, N = {
  [T.V1]: m
};
class tt extends z {
  constructor(t, { revision: s, ...e }) {
    if (super(t, e), typeof s == "string") {
      if (!N[s])
        throw Error(`Unknown pool revision: ${s}`);
      this.revision = new N[s]();
    } else
      this.revision = s;
  }
  get gasConstants() {
    return this.revision.gasConstants;
  }
  /**
   * Create a payload for the `collect_fees` transaction.
   *
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {Cell} payload for the `collect_fees` transaction.
   */
  async createCollectFeesBody(t) {
    return this.revision.createCollectFeesBody(this, t);
  }
  /**
   * Create a payload for the `burn` transaction.
   *
   * @param {BN | number} params.amount - Amount of lp tokens to burn (in basic token units)
   * @param {Address | string} params.responseAddress - Address of a user
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {Cell} payload for the `burn` transaction.
   */
  async createBurnBody(t) {
    return this.revision.createBurnBody(this, t);
  }
  /**
   * Estimate expected result of the amount of jettonWallet tokens swapped to the other type of tokens of the pool
   *
   * @param {BN | number} params.amount - Amount of tokens to swap (in basic token units)
   * @param {Address | string} params.jettonWallet - Token Jetton address (must be equal to one of the Jetton addresses of the pool)
   *
   * @returns {ExpectedOutputsData} structure with expected result of a token swap
   */
  async getExpectedOutputs(t) {
    return this.revision.getExpectedOutputs(this, t);
  }
  /**
   * Estimate an expected amount of lp tokens minted when providing liquidity.
   *
   * @param {BN | number} params.amount0 - Amount of tokens for the first Jetton (in basic token units)
   * @param {BN | number} params.amount1 - Amount of tokens for the second Jetton (in basic token units)
   *
   * @returns {BN} an estimated amount of liquidity tokens to be minted
   */
  async getExpectedTokens(t) {
    return this.revision.getExpectedTokens(this, t);
  }
  /**
   * Estimate expected liquidity freed upon burning liquidity tokens.
   *
   * @param {BN | number} params.jettonAmount - Amount of liquidity tokens (in basic token units)
   *
   * @returns {PoolAmountsData} structure with expected freed liquidity
   */
  async getExpectedLiquidity(t) {
    return this.revision.getExpectedLiquidity(this, t);
  }
  /**
   * @param {Address | string} params.ownerAddress - Address of a user
   *
   * @returns a JettonWallet object for an address returned by getJettonWalletAddress
   */
  async getJettonWallet(t) {
    const s = await this.getJettonWalletAddress(
      new q(t.ownerAddress)
    );
    return new H(this.provider, { address: s });
  }
  /**
   * @param {Address | string} params.ownerAddress - Address of a user
   *
   * @returns the lp account address of a user
   */
  async getLpAccountAddress(t) {
    return await this.revision.getLpAccountAddress(this, t);
  }
  /**
   * @param {Address | string} params.ownerAddress - Address of a user
   *
   * @returns {LpAccount} object for address returned by getLpAccountAddress
   */
  async getLpAccount(t) {
    const s = await this.getLpAccountAddress(t);
    return s ? new X(this.provider, {
      address: s,
      revision: this.revision.constructLpAccountRevision(this)
    }) : null;
  }
  /**
   * @returns {PoolData} containing current state of the pool
   */
  async getData() {
    return this.revision.getData(this);
  }
  /**
   * Build all data required to execute a `collect_fees` transaction.
   *
   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} all data required to execute a `collect_fees` transaction.
   */
  async buildCollectFeeTxParams(t) {
    const s = await this.getAddress(), e = await this.createCollectFeesBody({
      queryId: t == null ? void 0 : t.queryId
    }), n = new L(
      (t == null ? void 0 : t.gasAmount) ?? this.gasConstants.collectFees
    );
    return { to: s, payload: e, gasAmount: n };
  }
  /**
   * Build all data required to execute a `burn` transaction.
   *
   * @param {BN | number} params.amount - Amount of lp tokens to burn (in basic token units)
   * @param {Address | string} params.responseAddress - Address of a user
   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} all data required to execute a `burn` transaction.
   */
  async buildBurnTxParams(t) {
    const s = await this.getJettonWalletAddress(
      new q(t.responseAddress)
    ), e = await this.createBurnBody({
      amount: t.amount,
      responseAddress: t.responseAddress,
      queryId: t.queryId
    }), n = new L((t == null ? void 0 : t.gasAmount) ?? this.gasConstants.burn);
    return { to: s, payload: e, gasAmount: n };
  }
}
const {
  utils: { BN: F },
  boc: { Cell: et },
  Address: x
} = c;
function B(o) {
  const t = new et();
  return t.bits.writeUint(260734629, 32), t.bits.writeUint(o.queryId, 64), t.bits.writeCoins(new F(o.amount)), t.bits.writeAddress(new x(o.destination)), t.bits.writeAddress(
    o.responseDestination ? new x(o.responseDestination) : void 0
  ), o.customPayload ? (t.refs.push(o.customPayload), t.bits.writeBit(!0)) : t.bits.writeBit(!1), t.bits.writeCoins(new F(o.forwardTonAmount)), o.forwardPayload ? (t.refs.push(o.forwardPayload), t.bits.writeBit(!0)) : t.bits.writeBit(!1), t;
}
function I(o) {
  return !o.isZero();
}
const {
  Address: h,
  utils: { BN: f, bytesToBase64: J },
  boc: { Cell: C }
} = c;
class st {
  constructor() {
    this.createSwapBody = async (t, s) => {
      const e = new C();
      return e.bits.writeUint(g.SWAP, 32), e.bits.writeAddress(new h(s.askJettonWalletAddress)), e.bits.writeCoins(new f(s.minAskAmount)), e.bits.writeAddress(new h(s.userWalletAddress)), s.referralAddress ? (e.bits.writeUint(1, 1), e.bits.writeAddress(new h(s.referralAddress))) : e.bits.writeUint(0, 1), e;
    }, this.createProvideLiquidityBody = async (t, s) => {
      const e = new C();
      return e.bits.writeUint(g.PROVIDE_LIQUIDITY, 32), e.bits.writeAddress(new h(s.routerWalletAddress)), e.bits.writeCoins(new f(s.minLpOut)), e;
    }, this.getPoolAddress = async (t, s) => {
      const e = new C();
      e.bits.writeAddress(new h(s.token0));
      const n = new C();
      n.bits.writeAddress(new h(s.token1));
      const r = J(await e.toBoc(!1)), i = J(await n.toBoc(!1)), d = await t.getAddress(), l = await t.provider.call2(
        d.toString(),
        "get_pool_address",
        [
          ["tvm.Slice", r],
          ["tvm.Slice", i]
        ]
      );
      return a(l);
    }, this.getData = async (t) => {
      const s = await t.getAddress(), e = await t.provider.call2(
        s.toString(),
        "get_router_data",
        []
      );
      return {
        isLocked: I(e[0]),
        adminAddress: a(e[1]),
        tempUpgrade: e[2],
        poolCode: e[3],
        jettonLpWalletCode: e[4],
        lpAccountCode: e[5]
      };
    }, this.constructPoolRevision = (t) => new m();
  }
  get gasConstants() {
    return {
      swap: new f(3e8),
      provideLp: new f(3e8),
      swapForward: new f(265e6),
      provideLpForward: new f(265e6)
    };
  }
}
const {
  Address: $,
  Contract: nt,
  utils: { BN: w },
  token: {
    jetton: { JettonMinter: u }
  }
} = c, V = {
  [T.V1]: st
};
class ft extends nt {
  constructor(t, { revision: s, ...e }) {
    if (super(t, e), typeof s == "string") {
      if (!V[s])
        throw Error(`Unknown router revision: ${s}`);
      this.revision = new V[s]();
    } else
      this.revision = s;
  }
  get gasConstants() {
    return this.revision.gasConstants;
  }
  /**
   * Create a payload for the `swap` transaction.
   *
   * @param {Address | string} params.userWalletAddress - User's address
   * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)
   * @param {Address | string} params.askJettonWalletAddress - Jetton router's wallet address of tokens to be received
   * @param {Address | string | undefined} params.referralAddress - Optional; referral address
   *
   * @returns {Cell} payload for the `swap` transaction.
   */
  async createSwapBody(t) {
    return this.revision.createSwapBody(this, t);
  }
  /**
   * Create a payload for the `provide_lp` transaction.
   *
   * @param {Address | string} params.routerWalletAddress - Address of the router's Jetton token wallet
   * @param {BN | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)
   *
   * @returns payload for the `provide_lp` transaction.
   */
  async createProvideLiquidityBody(t) {
    return this.revision.createProvideLiquidityBody(this, t);
  }
  /**
   * **Note:** It's necessary to specify addresses of Jetton wallets of the router as the arguments of this method.
   * These addresses can be retrieved with getJettonWalletAddress of the Jetton minter.
   * @param {Address | string} params.token0 - The address of the router's wallet of first Jetton
   * @param {Address | string} params.token1 - The address of the router's wallet of second Jetton
   *
   * @returns {Address | null} an address of a pool for a specified pair of assets.
   */
  async getPoolAddress(t) {
    return this.revision.getPoolAddress(this, t);
  }
  /**
   * @param {[Address | string, Address | string]} params.jettonAddresses - Tuple of Jetton addresses of a pool
   *
   * @returns {Pool} object for a pool with specified Jetton token addresses.
   */
  async getPool(t) {
    const s = new u(
      this.provider,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      {
        address: t.jettonAddresses[0]
      }
    ), e = new u(
      this.provider,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      {
        address: t.jettonAddresses[1]
      }
    ), n = await this.getAddress(), r = await s.getJettonWalletAddress(
      n
    ), i = await e.getJettonWalletAddress(
      n
    ), d = await this.getPoolAddress({
      token0: r,
      token1: i
    });
    return d ? new tt(
      this.provider,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      {
        address: d,
        revision: this.revision.constructPoolRevision(this)
      }
    ) : null;
  }
  /**
   * @returns {RouterData} containing current state of the router.
   */
  async getData() {
    return await this.revision.getData(this);
  }
  /**
   * Build all data required to execute a jetton `swap` transaction
   *
   * @param {Address | string} params.userWalletAddress - User's address
   * @param {Address | string} params.offerJettonAddress - Jetton address of a token to be swapped
   * @param {Address | string} params.askJettonAddress - Jetton address of a token to be received
   * @param {BN | number} params.offerAmount - Amount of tokens to be swapped (in basic token units)
   * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)
   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)
   * @param {BN | number | undefined} params.forwardGasAmount - Optional; forward amount of gas for the next transaction (in nanoTons)
   * @param {Address | string | undefined} params.referralAddress - Optional; referral address
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} data required to execute a jetton `swap` transaction
   */
  async buildSwapJettonTxParams(t) {
    const s = new u(
      this.provider,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      {
        address: t.offerJettonAddress
      }
    ), e = new u(
      this.provider,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      {
        address: t.askJettonAddress
      }
    ), n = await s.getJettonWalletAddress(
      new $(t.userWalletAddress)
    ), r = await e.getJettonWalletAddress(
      await this.getAddress()
    ), i = await this.createSwapBody({
      userWalletAddress: t.userWalletAddress,
      minAskAmount: t.minAskAmount,
      askJettonWalletAddress: r,
      referralAddress: t.referralAddress
    }), d = new w(
      t.forwardGasAmount ?? this.gasConstants.swapForward
    ), l = B({
      queryId: t.queryId ?? 0,
      amount: t.offerAmount,
      destination: await this.getAddress(),
      forwardTonAmount: d,
      forwardPayload: i
    }), A = new w(t.gasAmount ?? this.gasConstants.swap);
    return {
      to: n,
      payload: l,
      gasAmount: A
    };
  }
  /**
   * Build all data required to execute a ton to jetton `swap` transaction
   *
   * @param {Address | string} params.userWalletAddress - User's address
   * @param {Address | string} params.proxyTonAddress - Address of a proxy ton contract
   * @param {Address | string} params.askJettonAddress - Jetton address of a token to be received
   * @param {BN | number} params.offerAmount - Amount of ton to be swapped (in nanoTons)
   * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)
   * @param {BN | number | undefined} params.forwardGasAmount - Optional; forward amount of gas for the next transaction (in nanoTons)
   * @param {Address | string | undefined} params.referralAddress - Optional; referral address
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} data required to execute a ton to jetton `swap` transaction
   */
  async buildSwapProxyTonTxParams(t) {
    const s = new u(
      this.provider,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      {
        address: t.proxyTonAddress
      }
    ), e = new u(
      this.provider,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      {
        address: t.askJettonAddress
      }
    ), n = await s.getJettonWalletAddress(
      await this.getAddress()
    ), r = await e.getJettonWalletAddress(
      await this.getAddress()
    ), i = await this.createSwapBody({
      userWalletAddress: t.userWalletAddress,
      minAskAmount: t.minAskAmount,
      askJettonWalletAddress: r,
      referralAddress: t.referralAddress
    }), d = new w(
      t.forwardGasAmount ?? this.gasConstants.swapForward
    ), l = B({
      queryId: t.queryId ?? 0,
      amount: t.offerAmount,
      destination: await this.getAddress(),
      forwardTonAmount: d,
      forwardPayload: i
    }), A = new w(t.offerAmount).add(d);
    return {
      to: n,
      payload: l,
      gasAmount: A
    };
  }
  /**
   * Collect all data required to execute a jetton `provide_lp` transaction
   *
   * @param {Address | string} params.userWalletAddress - User's address
   * @param {Address | string} params.sendTokenAddress - Address of the provided Jetton token
   * @param {Address | string} params.otherTokenAddress - Address of the other Jetton token in pair
   * @param {BN | number} params.sendAmount - Amount of the first token deposited as liquidity (in basic token units)
   * @param {BN | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)
   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)
   * @param {BN | number | undefined} params.forwardGasAmount - Optional; forward amount of gas for the next transaction (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} data required to execute a jetton `provide_lp` transaction
   */
  async buildProvideLiquidityJettonTxParams(t) {
    const s = new u(
      this.provider,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      {
        address: t.sendTokenAddress
      }
    ), e = new u(
      this.provider,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      {
        address: t.otherTokenAddress
      }
    ), n = await s.getJettonWalletAddress(
      new $(t.userWalletAddress)
    ), r = await e.getJettonWalletAddress(
      await this.getAddress()
    ), i = await this.createProvideLiquidityBody({
      routerWalletAddress: r,
      minLpOut: t.minLpOut
    }), d = new w(
      t.forwardGasAmount ?? this.gasConstants.provideLpForward
    ), l = B({
      queryId: t.queryId ?? 0,
      amount: t.sendAmount,
      destination: await this.getAddress(),
      forwardTonAmount: d,
      forwardPayload: i
    }), A = new w(t.gasAmount ?? this.gasConstants.provideLp);
    return {
      to: n,
      payload: l,
      gasAmount: A
    };
  }
  /**
   * Collect all data required to execute a proxy ton `provide_lp` transaction
   *
   * @param {Address | string} params.userWalletAddress - User's address
   * @param {Address | string} params.proxyTonAddress - Address of a proxy ton contract
   * @param {Address | string} params.otherTokenAddress - Address of the other Jetton token in pair
   * @param {BN | number} params.sendAmount - Amount of ton deposited as liquidity (in nanoTons)
   * @param {BN | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)
   * @param {BN | number | undefined} params.forwardGasAmount - Optional; forward amount of gas for the next transaction (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} data required to execute a proxy ton `provide_lp` transaction
   */
  async buildProvideLiquidityProxyTonTxParams(t) {
    const s = new u(
      this.provider,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      {
        address: t.proxyTonAddress
      }
    ), e = new u(
      this.provider,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      {
        address: t.otherTokenAddress
      }
    ), n = await s.getJettonWalletAddress(
      await this.getAddress()
    ), r = await e.getJettonWalletAddress(
      await this.getAddress()
    ), i = await this.createProvideLiquidityBody({
      routerWalletAddress: r,
      minLpOut: t.minLpOut
    }), d = new w(
      t.forwardGasAmount ?? this.gasConstants.provideLp
    ), l = B({
      queryId: t.queryId ?? 0,
      amount: t.sendAmount,
      destination: await this.getAddress(),
      forwardTonAmount: d,
      forwardPayload: i
    }), A = new w(t.sendAmount).add(d);
    return {
      to: n,
      payload: l,
      gasAmount: A
    };
  }
}
const E = {
  STAKE: 1858722917,
  CLAIM_REWARDS: 2027548937,
  UNSTAKE: 3106497952
}, K = {
  V2: "V2"
};
function ot(o) {
  return new TextDecoder().decode(o.bits.getTopUppedArray());
}
const {
  utils: { BN: M },
  boc: { Cell: rt }
} = c;
class it {
  constructor() {
    this.createStakeBody = async (t) => {
      const s = new rt();
      return s.bits.writeUint(E.STAKE, 32), s;
    }, this.getPendingData = async (t) => {
      const s = await t.getAddress(), e = await t.provider.call2(
        s.toString(),
        "get_pending_data"
      );
      return {
        changeCustodianTs: e[0],
        sendMsgTs: e[1],
        codeUpgradeTs: e[2],
        newCustodian: a(e[3]),
        pendingMsg: e[4],
        newCode: e[5],
        newStorage: e[6]
      };
    }, this.getVersion = async (t) => {
      const s = await t.getAddress(), e = await t.provider.call2(
        s.toString(),
        "get_version"
      );
      return {
        major: e[0],
        minor: e[1],
        development: ot(e[2])
      };
    }, this.getData = async (t) => {
      const s = await t.getAddress(), e = await t.provider.call2(
        s.toString(),
        "get_farming_minter_data"
      ), n = a(e[14]);
      if (!n)
        throw new Error(
          `Failed to parse stakingTokenWallet from cell: ${e[14]}`
        );
      const r = a(e[15]);
      if (!r)
        throw new Error(
          `Failed to parse rewardTokenWallet from cell: ${e[15]}`
        );
      return {
        nextItemIndex: e[0],
        lastUpdateTime: e[1],
        status: e[2],
        depositedNanorewards: e[3],
        currentStakedTokens: e[4],
        accruedPerUnitNanorewards: e[5],
        claimedFeeNanorewards: e[6],
        accruedFeeNanorewards: e[7],
        accruedNanorewards: e[8],
        claimedNanorewards: e[9],
        contractUniqueId: e[10],
        nanorewardsPer24h: e[11],
        adminFee: e[12],
        minStakeTime: e[13],
        stakingTokenWallet: n,
        rewardTokenWallet: r,
        custodianAddress: a(e[16]),
        canChangeCustodian: I(e[17]),
        canSendRawMsg: I(e[18]),
        canChangeFee: I(e[19]),
        unrestrictedDepositRewards: I(e[20]),
        // NFTs are always soulbound in V2
        soulboundItems: !0
      };
    };
  }
  get gasConstants() {
    return {
      stake: new M(3e8),
      stakeForward: new M(25e7)
    };
  }
}
const {
  Address: dt,
  utils: { BN: O },
  token: {
    nft: { NftCollection: at },
    jetton: { JettonMinter: ct, JettonWallet: ut }
  }
} = c, j = {
  [K.V2]: it
};
class Bt extends at {
  constructor(t, { revision: s, ...e }) {
    if (super(t, e), typeof s == "string") {
      if (!j[s])
        throw Error(`Unknown pool revision: ${s}`);
      this.revision = new j[s]();
    } else
      this.revision = s;
  }
  get gasConstants() {
    return this.revision.gasConstants;
  }
  /**
   * Create a payload for the `stake` transaction.
   *
   * @returns payload for the `stake` transaction.
   */
  async createStakeBody() {
    return this.revision.createStakeBody(this);
  }
  /**
   * @returns {Address} address of minter for staking jetton
   */
  async getStakingJettonAddress() {
    const { stakingTokenWallet: t } = await this.getData(), s = new ut(
      this.provider,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      {
        address: t
      }
    ), { jettonMinterAddress: e } = await s.getData();
    return e;
  }
  async getPendingData() {
    return this.revision.getPendingData(this);
  }
  async getVersion() {
    return this.revision.getVersion(this);
  }
  /**
   * @returns {FarmNftMinterData} containing current state of the minter
   */
  async getData() {
    return this.revision.getData(this);
  }
  /**
   * Build all data required to execute a jetton `stake` transaction
   *
   * @param {Address | string} params.userWalletAddress - User's address
   * @param {Address | string} params.jettonAddress - Jetton address of token to be staked
   * @param {BN | number} params.jettonAmount - Amount of tokens to be staked (in basic token units)
   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)
   * @param {BN | number | undefined} params.forwardGasAmount - Optional; forward amount of gas for the next transaction (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} containing all data required to execute a jetton `stake` transaction
   */
  async buildStakeTxParams(t) {
    const e = await new ct(
      this.provider,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      {
        address: t.jettonAddress
      }
    ).getJettonWalletAddress(
      new dt(t.userWalletAddress)
    ), n = await this.createStakeBody(), r = new O(
      t.forwardGasAmount ?? this.gasConstants.stakeForward
    ), i = B({
      queryId: t.queryId ?? 0,
      amount: t.jettonAmount,
      destination: await this.getAddress(),
      responseDestination: t.userWalletAddress,
      forwardTonAmount: r,
      forwardPayload: n
    }), d = new O(t.gasAmount ?? this.gasConstants.stake);
    return {
      to: e,
      payload: i,
      gasAmount: d
    };
  }
}
const {
  boc: { Cell: lt }
} = c;
function wt(o) {
  const t = new lt();
  return t.bits.writeUint(520377210, 32), t.bits.writeUint((o == null ? void 0 : o.queryId) ?? 0, 64), t;
}
const {
  utils: { BN: _ },
  boc: { Cell: G }
} = c;
class At {
  constructor() {
    this.createClaimRewardsBody = async (t, s) => {
      const e = new G();
      return e.bits.writeUint(E.CLAIM_REWARDS, 32), e.bits.writeUint((s == null ? void 0 : s.queryId) ?? 0, 64), e;
    }, this.createUnstakeBody = async (t, s) => {
      const e = new G();
      return e.bits.writeUint(E.UNSTAKE, 32), e.bits.writeUint((s == null ? void 0 : s.queryId) ?? 0, 64), e;
    }, this.createDestroyBody = async (t, s) => wt({
      queryId: (s == null ? void 0 : s.queryId) ?? 0
    }), this.getFarmingData = async (t) => {
      const s = await t.getAddress(), e = await t.provider.call2(
        s.toString(),
        "get_farming_data"
      );
      return {
        status: e[0],
        revokeTime: e[1],
        stakedTokens: e[2],
        claimedPerUnitNanorewards: e[3],
        stakeDate: e[4],
        // NFTs are always soulbound in V2
        isSoulbound: !0
      };
    };
  }
  get gasConstants() {
    return {
      claimRewards: new _(3e8),
      unstake: new _(4e8),
      destroy: new _(5e7)
    };
  }
}
const {
  utils: { BN: D },
  token: {
    nft: { NftItem: gt }
  }
} = c, p = {
  [K.V2]: At
};
class It extends gt {
  constructor(t, { revision: s, ...e }) {
    if (super(t, e), typeof s == "string") {
      if (!p[s])
        throw Error(`Unknown farm NFT item revision: ${s}`);
      this.revision = new p[s]();
    } else
      this.revision = s;
  }
  get gasConstants() {
    return this.revision.gasConstants;
  }
  /**
   * Creates payload for the `claim_rewards` transaction.
   *
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {Cell} payload for the `claim_rewards` transaction.
   */
  async createClaimRewardsBody(t) {
    return this.revision.createClaimRewardsBody(this, t);
  }
  /**
   * Creates payload for the `destroy` transaction.
   *
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {Cell} payload for the `destroy` transaction.
   */
  async createDestroyBody(t) {
    return this.revision.createDestroyBody(this, t);
  }
  /**
   * Creates payload for the `unstake` transaction.
   *
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {Cell} payload for the `unstake` transaction.
   */
  async createUnstakeBody(t) {
    return this.revision.createUnstakeBody(this, t);
  }
  /**
   * @returns {FarmNftItemFarmingData} structure containing current state of the farm NFT
   */
  async getFarmingData() {
    return await this.revision.getFarmingData(this);
  }
  /**
   * Build all data required to execute a `claim_rewards` transaction.
   *
   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} all data required to execute a `claim_rewards` transaction.
   */
  async buildClaimRewardsTxParams(t) {
    const s = await this.getAddress(), e = await this.createClaimRewardsBody({
      queryId: t == null ? void 0 : t.queryId
    }), n = new D(
      (t == null ? void 0 : t.gasAmount) ?? this.gasConstants.claimRewards
    );
    return { to: s, payload: e, gasAmount: n };
  }
  /**
   * Build all data required to execute a `unstake` transaction.
   *
   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} all data required to execute a `unstake` transaction.
   */
  async buildUnstakeTxParams(t) {
    const s = await this.getAddress(), e = await this.createUnstakeBody({ queryId: t == null ? void 0 : t.queryId }), n = new D((t == null ? void 0 : t.gasAmount) ?? this.gasConstants.unstake);
    return { to: s, payload: e, gasAmount: n };
  }
  /**
   * Build all data required to execute a `destroy` transaction.
   *
   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)
   * @param {BN | number | undefined} params.queryId - Optional; query id
   *
   * @returns {MessageData} all data required to execute a `destroy` transaction.
   */
  async buildDestroyTxParams(t) {
    const s = await this.getAddress(), e = await this.createDestroyBody({ queryId: t == null ? void 0 : t.queryId }), n = new D((t == null ? void 0 : t.gasAmount) ?? this.gasConstants.destroy);
    return {
      to: s,
      payload: e,
      gasAmount: n
    };
  }
}
const vt = a;
export {
  g as DEX_OP_CODES,
  E as FARM_OP_CODES,
  K as FARM_REVISION,
  It as FarmNftItem,
  At as FarmNftItemRevisionV2,
  Bt as FarmNftMinter,
  it as FarmNftMinterRevisionV2,
  X as LpAccount,
  Q as LpAccountRevisionV1,
  tt as Pool,
  m as PoolRevisionV1,
  T as ROUTER_REVISION,
  ht as ROUTER_REVISION_ADDRESS,
  ft as Router,
  st as RouterRevisionV1,
  B as createJettonTransferMessage,
  wt as createSbtDestroyMessage,
  a as parseAddress,
  vt as parseAddressFromCell,
  I as parseBoolean,
  ot as parseString
};
//# sourceMappingURL=index.js.map
