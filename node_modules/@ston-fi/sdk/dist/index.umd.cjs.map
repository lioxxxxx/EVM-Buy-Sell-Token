{"version":3,"file":"index.umd.cjs","sources":["../src/contracts/dex/constants.ts","../src/utils/parseAddress.ts","../src/contracts/dex/lp-account/LpAccountRevisionV1.ts","../src/contracts/dex/lp-account/LpAccount.ts","../src/contracts/dex/pool/PoolRevisionV1.ts","../src/contracts/dex/pool/Pool.ts","../src/utils/createJettonTransferMessage.ts","../src/utils/parseBoolean.ts","../src/contracts/dex/router/RouterRevisionV1.ts","../src/contracts/dex/router/Router.ts","../src/contracts/farm/constants.ts","../src/utils/parseString.ts","../src/contracts/farm/minter/FarmNftMinterRevisionV2.ts","../src/contracts/farm/minter/FarmNftMinter.ts","../src/utils/createSbtDestroyMessage.ts","../src/contracts/farm/nft/FarmNftItemRevisionV2.ts","../src/contracts/farm/nft/FarmNftItem.ts","../src/utils/index.ts"],"sourcesContent":["export const DEX_OP_CODES = {\n  ADD_LIQUIDITY: 0x7362d09c,\n  SWAP: 0x25938561,\n  PROVIDE_LIQUIDITY: 0xfcf9e58f,\n  DIRECT_ADD_LIQUIDITY: 0x4cf82803,\n  REFUND: 0x0bf3f447,\n  RESET_GAS: 0x42a0fb43,\n  COLLECT_FEES: 0x1fcb7d3d,\n  REQUEST_BURN: 0x595f07bc,\n} as const;\n\nexport const ROUTER_REVISION = {\n  V1: 'V1',\n} as const;\n\nexport const ROUTER_REVISION_ADDRESS: Record<\n  keyof typeof ROUTER_REVISION,\n  string\n> = {\n  [ROUTER_REVISION.V1]: 'EQB3ncyBUTjZUA5EnFKR5_EnOMI9V1tTEAAPaiU71gc4TiUt',\n} as const;\n","import TonWeb from 'tonweb';\n\nimport type { Address, Cell } from '@/types';\n\nconst { Address } = TonWeb;\n\nconst readIntFromBitString = (\n  bs: Cell['bits'],\n  cursor: number,\n  bits: number,\n) => {\n  let n = BigInt(0);\n\n  for (let i = 0; i < bits; i++) {\n    n *= BigInt(2);\n    n += BigInt(bs.get(cursor + i));\n  }\n\n  return n;\n};\n\nexport const parseAddress = (cell: Cell): Address | null => {\n  try {\n    let n = readIntFromBitString(cell.bits, 3, 8);\n\n    if (n > BigInt(127)) {\n      n = n - BigInt(256);\n    }\n\n    const hashPart = readIntFromBitString(cell.bits, 3 + 8, 256);\n\n    if (n.toString(10) + ':' + hashPart.toString(16) === '0:0') {\n      return null;\n    }\n\n    const s = n.toString(10) + ':' + hashPart.toString(16).padStart(64, '0');\n\n    return new Address(s);\n  } catch {\n    return null;\n  }\n};\n","import TonWeb from 'tonweb';\n\nimport { parseAddress } from '@/utils/parseAddress';\nimport { DEX_OP_CODES } from '../constants';\nimport type { Cell, BN } from '@/types';\n\nimport type { LpAccountRevision } from './LpAccountRevision';\n\nconst {\n  boc: { Cell },\n  utils: { BN },\n} = TonWeb;\n\nexport class LpAccountRevisionV1 implements LpAccountRevision {\n  public get gasConstants(): LpAccountRevision['gasConstants'] {\n    return {\n      refund: new BN(500000000),\n      directAddLp: new BN(300000000),\n      resetGas: new BN(300000000),\n    };\n  }\n\n  public createRefundBody: LpAccountRevision['createRefundBody'] = async (\n    _lpAccount,\n    params,\n  ) => {\n    const message = new Cell();\n\n    message.bits.writeUint(DEX_OP_CODES.REFUND, 32);\n    message.bits.writeUint(params?.queryId ?? 0, 64);\n\n    return message;\n  };\n\n  public createDirectAddLiquidityBody: LpAccountRevision['createDirectAddLiquidityBody'] =\n    async (_lpAccount, params) => {\n      const message = new Cell();\n\n      message.bits.writeUint(DEX_OP_CODES.DIRECT_ADD_LIQUIDITY, 32);\n      message.bits.writeUint(params.queryId ?? 0, 64);\n      message.bits.writeCoins(new BN(params.amount0));\n      message.bits.writeCoins(new BN(params.amount1));\n      message.bits.writeCoins(new BN(params.minimumLpToMint ?? 1));\n\n      return message;\n    };\n\n  public createResetGasBody: LpAccountRevision['createResetGasBody'] = async (\n    _lpAccount,\n    params,\n  ) => {\n    const message = new Cell();\n\n    message.bits.writeUint(DEX_OP_CODES.RESET_GAS, 32);\n    message.bits.writeUint(params?.queryId ?? 0, 64);\n\n    return message;\n  };\n\n  public getData: LpAccountRevision['getData'] = async (lpAccount) => {\n    const contractAddress = await lpAccount.getAddress();\n    const result = await lpAccount.provider.call2(\n      contractAddress.toString(),\n      'get_lp_account_data',\n    );\n\n    return {\n      userAddress: parseAddress(result[0]),\n      poolAddress: parseAddress(result[1]),\n      amount0: result[2] as BN,\n      amount1: result[3] as BN,\n    };\n  };\n}\n","import TonWeb from 'tonweb';\n\nimport { ROUTER_REVISION } from '../constants';\nimport type {\n  Address,\n  Cell,\n  HttpProvider,\n  BN,\n  AddressType,\n  QueryIdType,\n  ContractOptions,\n  MessageData,\n  AmountType,\n} from '@/types';\n\nimport type {\n  LpAccountRevision,\n  LpAccountGasConstants,\n} from './LpAccountRevision';\nimport { LpAccountRevisionV1 } from './LpAccountRevisionV1';\n\nconst {\n  Contract,\n  utils: { BN },\n} = TonWeb;\n\nconst REVISIONS = {\n  [ROUTER_REVISION.V1]: LpAccountRevisionV1,\n} as const;\n\n/**\n * @type {LpAccountData} represent state of the lp account.\n *\n * @property {Address | null} userAddress - Owner's address\n * @property {Address | null} poolAddress - Pool's address\n * @property {BN} amount0 - Balance of the first Jetton token (in basic token units)\n * @property {BN} amount1 - Balance of the second Jetton token (in basic token units)\n */\nexport type LpAccountData = {\n  userAddress: Address | null;\n  poolAddress: Address | null;\n  amount0: BN;\n  amount1: BN;\n};\n\ninterface LpAccountOptions extends ContractOptions {\n  revision: LpAccountRevision | keyof typeof REVISIONS;\n  address: AddressType;\n}\n\n/**\n * @type {LpAccount} represents the lp account contract and provide methods to interact with it.\n *\n * The lp account contract holds information about the liquidity provided by the user before minting new liquidity.\n * It interacts only with a single pool contract. For each user, there is single account contract for each pool.\n * The router “routes” the temporary liquidity to the correct account contract.\n * Then the account contract calls the pool contract again to mint new liquidity (once it satisfies some requirements).\n */\nexport class LpAccount extends Contract {\n  private revision: LpAccountRevision;\n\n  constructor(\n    provider: HttpProvider,\n    { revision, ...options }: LpAccountOptions,\n  ) {\n    super(provider, options);\n\n    if (typeof revision === 'string') {\n      if (!REVISIONS[revision])\n        throw Error(`Unknown account revision: ${revision}`);\n\n      this.revision = new REVISIONS[revision]();\n    } else {\n      this.revision = revision;\n    }\n  }\n\n  public get gasConstants(): LpAccountGasConstants {\n    return this.revision.gasConstants;\n  }\n\n  /**\n   * Create a payload for the `refund_me` transaction.\n   *\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {Cell} payload for the `refund_me` transaction.\n   */\n  public async createRefundBody(params?: {\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    return this.revision.createRefundBody(this, params);\n  }\n\n  /**\n   * Create a payload for the `direct_add_liquidity` transaction.\n   *\n   * @param {BN | number} params.amount0 - Amount of the first Jetton tokens (in basic token units)\n   * @param {BN | number} params.amount1 - Amount of the second Jetton tokens (in basic token units)\n   * @param {BN | number | undefined} params.minimumLpToMint - Optional; minimum amount of received liquidity tokens (in basic token units)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {Cell} payload for the `direct_add_liquidity` transaction.\n   */\n  public async createDirectAddLiquidityBody(params: {\n    amount0: AmountType;\n    amount1: AmountType;\n    minimumLpToMint?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    return this.revision.createDirectAddLiquidityBody(this, params);\n  }\n\n  /**\n   * Create a payload for the `reset_gas` transaction.\n   *\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {Cell} payload for the `reset_gas` transaction.\n   */\n  public async createResetGasBody(params?: {\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    return this.revision.createResetGasBody(this, params);\n  }\n\n  /**\n   * @returns {LpAccountData} structure containing current state of the lp account.\n   */\n  public async getData(): Promise<LpAccountData> {\n    return await this.revision.getData(this);\n  }\n\n  /**\n   * Build all data required to execute a `refund_me` transaction.\n   *\n   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} all data required to execute a `refund_me` transaction.\n   */\n  public async buildRefundTxParams(params?: {\n    gasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const to = await this.getAddress();\n\n    const payload = await this.createRefundBody({ queryId: params?.queryId });\n\n    const gasAmount = new BN(params?.gasAmount ?? this.gasConstants.refund);\n\n    return { to, payload, gasAmount };\n  }\n\n  /**\n   * Build all data required to execute a `direct_add_liquidity` transaction.\n   *\n   * @param {BN | number} params.amount0 - Amount of the first Jetton tokens (in basic token units)\n   * @param {BN | number} params.amount1 - Amount of the second Jetton tokens (in basic token units)\n   * @param {BN | number | undefined} params.minimumLpToMint - Optional; minimum amount of received liquidity tokens (in basic token units)\n   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} all data required to execute a `direct_add_liquidity` transaction.\n   */\n  public async buildDirectAddLiquidityTxParams(params: {\n    amount0: AmountType;\n    amount1: AmountType;\n    minimumLpToMint?: AmountType;\n    gasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const to = await this.getAddress();\n\n    const payload = await this.createDirectAddLiquidityBody({\n      amount0: params.amount0,\n      amount1: params.amount1,\n      minimumLpToMint: params.minimumLpToMint,\n      queryId: params.queryId,\n    });\n\n    const gasAmount = new BN(params.gasAmount ?? this.gasConstants.directAddLp);\n\n    return { to, payload, gasAmount };\n  }\n\n  /**\n   * Build all data required to execute a `reset_gas` transaction.\n   *\n   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} all data required to execute a `reset_gas` transaction.\n   */\n  public async buildResetGasTxParams(params?: {\n    gasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const to = await this.getAddress();\n\n    const payload = await this.createResetGasBody({ queryId: params?.queryId });\n\n    const gasAmount = new BN(params?.gasAmount ?? this.gasConstants.resetGas);\n\n    return { to, payload, gasAmount };\n  }\n}\n","import TonWeb from 'tonweb';\n\nimport { LpAccountRevisionV1 } from '../lp-account/LpAccountRevisionV1';\nimport { parseAddress } from '@/utils/parseAddress';\nimport { DEX_OP_CODES } from '../constants';\nimport type { Address, Cell, BN } from '@/types';\n\nimport type { PoolRevision } from './PoolRevision';\n\nconst {\n  utils: { BN, bytesToBase64 },\n  boc: { Cell },\n  Address,\n} = TonWeb;\n\nexport class PoolRevisionV1 implements PoolRevision {\n  public get gasConstants(): PoolRevision['gasConstants'] {\n    return {\n      collectFees: new BN(1100000000),\n      burn: new BN(500000000),\n    };\n  }\n\n  public createCollectFeesBody: PoolRevision['createCollectFeesBody'] = async (\n    _pool,\n    params,\n  ) => {\n    const message = new Cell();\n\n    message.bits.writeUint(DEX_OP_CODES.COLLECT_FEES, 32);\n    message.bits.writeUint(params?.queryId ?? 0, 64);\n\n    return message;\n  };\n\n  public createBurnBody: PoolRevision['createBurnBody'] = async (\n    _pool,\n    params,\n  ) => {\n    const message = new Cell();\n\n    message.bits.writeUint(DEX_OP_CODES.REQUEST_BURN, 32);\n    message.bits.writeUint(params.queryId ?? 0, 64);\n    message.bits.writeCoins(new BN(params.amount));\n    message.bits.writeAddress(new Address(params.responseAddress));\n\n    return message;\n  };\n\n  public getExpectedOutputs: PoolRevision['getExpectedOutputs'] = async (\n    pool,\n    params,\n  ) => {\n    const cell = new Cell();\n\n    cell.bits.writeAddress(new Address(params.jettonWallet));\n\n    const slice = bytesToBase64(await cell.toBoc(false));\n\n    const poolAddress = await pool.getAddress();\n    const result = await pool.provider.call2(\n      poolAddress.toString(),\n      'get_expected_outputs',\n      [\n        ['int', params.amount.toString()],\n        ['tvm.Slice', slice],\n      ],\n    );\n\n    return {\n      jettonToReceive: result[0] as BN,\n      protocolFeePaid: result[1] as BN,\n      refFeePaid: result[2] as BN,\n    };\n  };\n\n  public getExpectedTokens: PoolRevision['getExpectedTokens'] = async (\n    pool,\n    params,\n  ) => {\n    const poolAddress = await pool.getAddress();\n    const result = await pool.provider.call2(\n      poolAddress.toString(),\n      'get_expected_tokens',\n      [\n        ['int', params.amount0.toString()],\n        ['int', params.amount1.toString()],\n      ],\n    );\n\n    return result as BN;\n  };\n\n  public getExpectedLiquidity: PoolRevision['getExpectedLiquidity'] = async (\n    pool,\n    params,\n  ) => {\n    const poolAddress = await pool.getAddress();\n    const result = await pool.provider.call2(\n      poolAddress.toString(),\n      'get_expected_liquidity',\n      [['int', params.jettonAmount.toString()]],\n    );\n\n    return {\n      amount0: result[0] as BN,\n      amount1: result[1] as BN,\n    };\n  };\n\n  public getLpAccountAddress: PoolRevision['getLpAccountAddress'] = async (\n    pool,\n    params,\n  ) => {\n    const cell = new Cell();\n\n    cell.bits.writeAddress(new Address(params.ownerAddress));\n\n    const slice = bytesToBase64(await cell.toBoc(false));\n    const poolAddress = await pool.getAddress();\n\n    const result = await pool.provider.call2(\n      poolAddress.toString(),\n      'get_lp_account_address',\n      [['tvm.Slice', slice]],\n    );\n\n    return parseAddress(result);\n  };\n\n  public constructLpAccountRevision: PoolRevision['constructLpAccountRevision'] =\n    (_pool) => new LpAccountRevisionV1();\n\n  public getData: PoolRevision['getData'] = async (pool) => {\n    const contractAddress = await pool.getAddress();\n\n    const result = await pool.provider.call2(\n      contractAddress.toString(),\n      'get_pool_data',\n    );\n\n    return {\n      reserve0: result[0] as BN,\n      reserve1: result[1] as BN,\n      token0WalletAddress: parseAddress(result[2]),\n      token1WalletAddress: parseAddress(result[3]),\n      lpFee: result[4] as BN,\n      protocolFee: result[5] as BN,\n      refFee: result[6] as BN,\n      protocolFeeAddress: parseAddress(result[7]),\n      collectedToken0ProtocolFee: result[8] as BN,\n      collectedToken1ProtocolFee: result[9] as BN,\n    };\n  };\n}\n","import TonWeb from 'tonweb';\n\nimport { LpAccount } from '../lp-account/LpAccount';\nimport { ROUTER_REVISION } from '../constants';\nimport type {\n  Address,\n  Cell,\n  HttpProvider,\n  JettonMinter,\n  JettonWallet,\n  BN,\n  AddressType,\n  QueryIdType,\n  JettonMinterOptions,\n  MessageData,\n  AmountType,\n} from '@/types';\n\nimport { PoolGasConstants, PoolRevision } from './PoolRevision';\nimport { PoolRevisionV1 } from './PoolRevisionV1';\n\nconst {\n  Address,\n  utils: { BN },\n  token: {\n    jetton: { JettonMinter, JettonWallet },\n  },\n} = TonWeb;\n\nconst REVISIONS = {\n  [ROUTER_REVISION.V1]: PoolRevisionV1,\n} as const;\n\n/**\n * @type {PoolData} state of the pool: Jetton token reserves, Jetton wallet addresses and fee parameters.\n *\n * @property {BN} reserve0 - Amount of the first token (in basic token units)\n * @property {BN} reserve1 - Amount of the second token (in basic token units)\n * @property {Address | null} token0WalletAddress - Address of the first Jetton token\n * @property {Address | null} token1WalletAddress - Address of the second Jetton token\n * @property {BN} lpFee - Liquidity pool fee value\n * @property {BN} protocolFee - Protocol fee\n * @property {BN} refFee - Referral fee\n * @property {Address | null} protocolFeeAddress - Address for receiving protocol fees\n * @property {BN} collectedToken0ProtocolFee - Amount of collected protocol fees of the first token (in basic token units)\n * @property {BN} collectedToken1ProtocolFee - Amount of collected protocol fees of the second token (in basic token units)\n */\nexport type PoolData = {\n  reserve0: BN;\n  reserve1: BN;\n  token0WalletAddress: Address | null;\n  token1WalletAddress: Address | null;\n  lpFee: BN;\n  protocolFee: BN;\n  refFee: BN;\n  protocolFeeAddress: Address | null;\n  collectedToken0ProtocolFee: BN;\n  collectedToken1ProtocolFee: BN;\n};\n\n/**\n * @type {ExpectedOutputsData}\n *\n * @property {BN} jettonToReceive - Amount of tokens received (in basic token units)\n * @property {BN} protocolFeePaid - Amount tokens paid for protocol fees (in basic token units)\n * @property {BN} refFeePaid - Amount tokens paid for referral fees (in basic token units)\n */\nexport type ExpectedOutputsData = {\n  jettonToReceive: BN;\n  protocolFeePaid: BN;\n  refFeePaid: BN;\n};\n\n/**\n * @type {PoolAmountsData}\n *\n * @property {BN} amount0 - Amount of tokens for the first Jetton (in basic token units)\n * @property {BN} amount1 - Amount of tokens for the second Jetton (in basic token units)\n */\nexport type PoolAmountsData = {\n  amount0: BN;\n  amount1: BN;\n};\n\ninterface PoolOptions extends JettonMinterOptions {\n  revision: PoolRevision | keyof typeof REVISIONS;\n  address: AddressType;\n}\n\n/**\n * @type {Pool} represents the pool contract and provide methods to interact with it.\n *\n * The pool is the contract that stores the AMM data for a certain pair and is responsible for handling “swaps” or providing liquidity for a certain pool.\n * For each pair (e.g. WTON/USDT), there is only a single pool contract.\n * The pool is also a Jetton Minter, and handles minting/burning of Liquidity Provider Jettons.\n * All the swap/lp calculations are done in the pool contract.\n */\nexport class Pool extends JettonMinter {\n  private revision: PoolRevision;\n\n  constructor(provider: HttpProvider, { revision, ...options }: PoolOptions) {\n    super(provider, options);\n\n    if (typeof revision === 'string') {\n      if (!REVISIONS[revision])\n        throw Error(`Unknown pool revision: ${revision}`);\n\n      this.revision = new REVISIONS[revision]();\n    } else {\n      this.revision = revision;\n    }\n  }\n\n  public get gasConstants(): PoolGasConstants {\n    return this.revision.gasConstants;\n  }\n\n  /**\n   * Create a payload for the `collect_fees` transaction.\n   *\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {Cell} payload for the `collect_fees` transaction.\n   */\n  public async createCollectFeesBody(params?: {\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    return this.revision.createCollectFeesBody(this, params);\n  }\n\n  /**\n   * Create a payload for the `burn` transaction.\n   *\n   * @param {BN | number} params.amount - Amount of lp tokens to burn (in basic token units)\n   * @param {Address | string} params.responseAddress - Address of a user\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {Cell} payload for the `burn` transaction.\n   */\n  public async createBurnBody(params: {\n    amount: AmountType;\n    responseAddress: AddressType;\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    return this.revision.createBurnBody(this, params);\n  }\n\n  /**\n   * Estimate expected result of the amount of jettonWallet tokens swapped to the other type of tokens of the pool\n   *\n   * @param {BN | number} params.amount - Amount of tokens to swap (in basic token units)\n   * @param {Address | string} params.jettonWallet - Token Jetton address (must be equal to one of the Jetton addresses of the pool)\n   *\n   * @returns {ExpectedOutputsData} structure with expected result of a token swap\n   */\n  public async getExpectedOutputs(params: {\n    amount: AmountType;\n    jettonWallet: AddressType;\n  }): Promise<ExpectedOutputsData> {\n    return this.revision.getExpectedOutputs(this, params);\n  }\n\n  /**\n   * Estimate an expected amount of lp tokens minted when providing liquidity.\n   *\n   * @param {BN | number} params.amount0 - Amount of tokens for the first Jetton (in basic token units)\n   * @param {BN | number} params.amount1 - Amount of tokens for the second Jetton (in basic token units)\n   *\n   * @returns {BN} an estimated amount of liquidity tokens to be minted\n   */\n  public async getExpectedTokens(params: {\n    amount0: AmountType;\n    amount1: AmountType;\n  }): Promise<BN> {\n    return this.revision.getExpectedTokens(this, params);\n  }\n\n  /**\n   * Estimate expected liquidity freed upon burning liquidity tokens.\n   *\n   * @param {BN | number} params.jettonAmount - Amount of liquidity tokens (in basic token units)\n   *\n   * @returns {PoolAmountsData} structure with expected freed liquidity\n   */\n  public async getExpectedLiquidity(params: {\n    jettonAmount: AmountType;\n  }): Promise<PoolAmountsData> {\n    return this.revision.getExpectedLiquidity(this, params);\n  }\n\n  /**\n   * @param {Address | string} params.ownerAddress - Address of a user\n   *\n   * @returns a JettonWallet object for an address returned by getJettonWalletAddress\n   */\n  public async getJettonWallet(params: {\n    ownerAddress: AddressType;\n  }): Promise<JettonWallet> {\n    const poolWalletAddress = await this.getJettonWalletAddress(\n      new Address(params.ownerAddress),\n    );\n    return new JettonWallet(this.provider, { address: poolWalletAddress });\n  }\n\n  /**\n   * @param {Address | string} params.ownerAddress - Address of a user\n   *\n   * @returns the lp account address of a user\n   */\n  public async getLpAccountAddress(params: {\n    ownerAddress: AddressType;\n  }): Promise<Address | null> {\n    return await this.revision.getLpAccountAddress(this, params);\n  }\n\n  /**\n   * @param {Address | string} params.ownerAddress - Address of a user\n   *\n   * @returns {LpAccount} object for address returned by getLpAccountAddress\n   */\n  public async getLpAccount(params: {\n    ownerAddress: AddressType;\n  }): Promise<LpAccount | null> {\n    const accountAddress = await this.getLpAccountAddress(params);\n\n    if (!accountAddress) return null;\n\n    return new LpAccount(this.provider, {\n      address: accountAddress,\n      revision: this.revision.constructLpAccountRevision(this),\n    });\n  }\n\n  /**\n   * @returns {PoolData} containing current state of the pool\n   */\n  public async getData(): Promise<PoolData> {\n    return this.revision.getData(this);\n  }\n\n  /**\n   * Build all data required to execute a `collect_fees` transaction.\n   *\n   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} all data required to execute a `collect_fees` transaction.\n   */\n  public async buildCollectFeeTxParams(params?: {\n    gasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const to = await this.getAddress();\n\n    const payload = await this.createCollectFeesBody({\n      queryId: params?.queryId,\n    });\n\n    const gasAmount = new BN(\n      params?.gasAmount ?? this.gasConstants.collectFees,\n    );\n\n    return { to, payload, gasAmount };\n  }\n\n  /**\n   * Build all data required to execute a `burn` transaction.\n   *\n   * @param {BN | number} params.amount - Amount of lp tokens to burn (in basic token units)\n   * @param {Address | string} params.responseAddress - Address of a user\n   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} all data required to execute a `burn` transaction.\n   */\n  public async buildBurnTxParams(params: {\n    amount: AmountType;\n    responseAddress: AddressType;\n    gasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const to = await this.getJettonWalletAddress(\n      new Address(params.responseAddress),\n    );\n\n    const payload = await this.createBurnBody({\n      amount: params.amount,\n      responseAddress: params.responseAddress,\n      queryId: params.queryId,\n    });\n\n    const gasAmount = new BN(params?.gasAmount ?? this.gasConstants.burn);\n\n    return { to, payload, gasAmount };\n  }\n}\n","import TonWeb from 'tonweb';\n\nimport type { AddressType, QueryIdType, AmountType, Cell } from '@/types';\n\nconst {\n  utils: { BN },\n  boc: { Cell },\n  Address,\n} = TonWeb;\n\n/**\n * Implements `transfer` function from Jettons Standard.\n * [Docs](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md#1-transfer)\n *\n * ```TL-B\n * transfer#0f8a7ea5 query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress response_destination:MsgAddress custom_payload:(Maybe ^Cell) forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell) = InternalMsgBody;\n * ```\n */\nexport function createJettonTransferMessage(params: {\n  queryId: QueryIdType;\n  amount: AmountType;\n  destination: AddressType;\n  responseDestination?: AddressType;\n  customPayload?: Cell;\n  forwardTonAmount: AmountType;\n  forwardPayload?: Cell;\n}) {\n  const message = new Cell();\n\n  message.bits.writeUint(0xf8a7ea5, 32);\n  message.bits.writeUint(params.queryId, 64);\n  message.bits.writeCoins(new BN(params.amount));\n  message.bits.writeAddress(new Address(params.destination));\n  message.bits.writeAddress(\n    params.responseDestination\n      ? new Address(params.responseDestination)\n      : undefined,\n  );\n\n  if (params.customPayload) {\n    message.refs.push(params.customPayload);\n    message.bits.writeBit(true);\n  } else {\n    message.bits.writeBit(false);\n  }\n\n  message.bits.writeCoins(new BN(params.forwardTonAmount));\n\n  if (params.forwardPayload) {\n    message.refs.push(params.forwardPayload);\n    message.bits.writeBit(true);\n  } else {\n    message.bits.writeBit(false);\n  }\n\n  return message;\n}\n","import type { BN } from '@/types';\n\n/**\n * [Docs](https://docs.ton.org/develop/func/types#absence-of-boolean-type)\n *\n * In FunC, booleans are represented as integers;\n * false is represented as 0 and true is represented as -1 (257 ones in binary notation).\n * When a condition is checked, every non-zero integer is considered a true value.\n */\nexport function parseBoolean(bn: BN) {\n  return !bn.isZero();\n}\n","import TonWeb from 'tonweb';\n\nimport { PoolRevisionV1 } from '../pool/PoolRevisionV1';\nimport { parseAddress } from '@/utils/parseAddress';\nimport { DEX_OP_CODES } from '../constants';\nimport type { Cell, BN } from '@/types';\nimport { parseBoolean } from '@/utils/parseBoolean';\n\nimport type { RouterRevision } from './RouterRevision';\n\nconst {\n  Address,\n  utils: { BN, bytesToBase64 },\n  boc: { Cell },\n} = TonWeb;\n\nexport class RouterRevisionV1 implements RouterRevision {\n  public get gasConstants(): RouterRevision['gasConstants'] {\n    return {\n      swap: new BN(300000000),\n      provideLp: new BN(300000000),\n      swapForward: new BN(265000000),\n      provideLpForward: new BN(265000000),\n    };\n  }\n\n  public createSwapBody: RouterRevision['createSwapBody'] = async (\n    _router,\n    params,\n  ) => {\n    const payload = new Cell();\n\n    payload.bits.writeUint(DEX_OP_CODES.SWAP, 32);\n    payload.bits.writeAddress(new Address(params.askJettonWalletAddress));\n    payload.bits.writeCoins(new BN(params.minAskAmount));\n    payload.bits.writeAddress(new Address(params.userWalletAddress));\n\n    if (params.referralAddress) {\n      payload.bits.writeUint(1, 1);\n      payload.bits.writeAddress(new Address(params.referralAddress));\n    } else {\n      payload.bits.writeUint(0, 1);\n    }\n\n    return payload;\n  };\n\n  public createProvideLiquidityBody: RouterRevision['createProvideLiquidityBody'] =\n    async (_router, params) => {\n      const payload = new Cell();\n\n      payload.bits.writeUint(DEX_OP_CODES.PROVIDE_LIQUIDITY, 32);\n      payload.bits.writeAddress(new Address(params.routerWalletAddress));\n      payload.bits.writeCoins(new BN(params.minLpOut));\n\n      return payload;\n    };\n\n  public getPoolAddress: RouterRevision['getPoolAddress'] = async (\n    router,\n    params,\n  ) => {\n    const cellA = new Cell();\n    cellA.bits.writeAddress(new Address(params.token0));\n\n    const cellB = new Cell();\n    cellB.bits.writeAddress(new Address(params.token1));\n\n    const sliceA = bytesToBase64(await cellA.toBoc(false));\n    const sliceB = bytesToBase64(await cellB.toBoc(false));\n\n    const routerAddress = await router.getAddress();\n    const result = await router.provider.call2(\n      routerAddress.toString(),\n      'get_pool_address',\n      [\n        ['tvm.Slice', sliceA],\n        ['tvm.Slice', sliceB],\n      ],\n    );\n\n    return parseAddress(result);\n  };\n\n  public getData: RouterRevision['getData'] = async (router) => {\n    const routerAddress = await router.getAddress();\n    const result = await router.provider.call2(\n      routerAddress.toString(),\n      'get_router_data',\n      [],\n    );\n\n    return {\n      isLocked: parseBoolean(result[0]),\n      adminAddress: parseAddress(result[1] as Cell),\n      tempUpgrade: result[2] as Cell,\n      poolCode: result[3] as Cell,\n      jettonLpWalletCode: result[4] as Cell,\n      lpAccountCode: result[5] as Cell,\n    };\n  };\n\n  public constructPoolRevision: RouterRevision['constructPoolRevision'] = (\n    _router,\n  ) => new PoolRevisionV1();\n}\n","import TonWeb from 'tonweb';\n\nimport { Pool } from '../pool/Pool';\nimport { ROUTER_REVISION } from '../constants';\nimport { createJettonTransferMessage } from '@/utils/createJettonTransferMessage';\nimport type {\n  Address,\n  Cell,\n  Contract,\n  HttpProvider,\n  JettonMinter,\n  AddressType,\n  AmountType,\n  MessageData,\n  QueryIdType,\n  ContractOptions,\n} from '@/types';\n\nimport type { RouterGasConstants, RouterRevision } from './RouterRevision';\nimport { RouterRevisionV1 } from './RouterRevisionV1';\n\nconst {\n  Address,\n  Contract,\n  utils: { BN },\n  token: {\n    jetton: { JettonMinter },\n  },\n} = TonWeb;\n\nconst REVISIONS = {\n  [ROUTER_REVISION.V1]: RouterRevisionV1,\n} as const;\n\n/**\n * @type {RouterData} containing state of the router\n *\n * @property {boolean} isLocked - true if transfer_notification operations are locked (swap, provide_lp)\n * @property {Address} adminAddress - Address of contract's admin account\n * @property {Cell} tempUpgrade - A structure describing state of contract's code & admin upgrade; zero values indicate that no upgrade is pending\n * @property {Cell} poolCode - Code of the router's liquidity pool contract\n * @property {Cell} jettonLpWalletCode - Code of lp wallet contract\n * @property {Cell} lpAccountCode - Code of lp account contract\n */\nexport type RouterData = {\n  isLocked: boolean;\n  adminAddress: Address | null;\n  tempUpgrade: Cell;\n  poolCode: Cell;\n  jettonLpWalletCode: Cell;\n  lpAccountCode: Cell;\n};\n\ninterface RouterOptions extends ContractOptions {\n  address: AddressType;\n  revision: RouterRevision | keyof typeof REVISIONS;\n}\n\n/**\n * @type {Router} represents the router contract and provide methods to interact with it.\n *\n * The router is the contract that acts as an entrypoint for all DEX calls.\n * It is responsible for routing all Jetton calls with transfer_notification op to the correct pool contract.\n * It acts as a sovereign over the DEX, and can be used to lock/unlock trading on all pools,\n * to change fees on a certain pool or to upgrade its own contract. The router is the only contract that can be upgraded.\n * Each Jetton that goes through the DEX is owned by the router. The router does not store anything about pairs.\n */\nexport class Router extends Contract {\n  private revision: RouterRevision;\n\n  constructor(provider: HttpProvider, { revision, ...options }: RouterOptions) {\n    super(provider, options);\n\n    if (typeof revision === 'string') {\n      if (!REVISIONS[revision])\n        throw Error(`Unknown router revision: ${revision}`);\n\n      this.revision = new REVISIONS[revision]();\n    } else {\n      this.revision = revision;\n    }\n  }\n\n  public get gasConstants(): RouterGasConstants {\n    return this.revision.gasConstants;\n  }\n\n  /**\n   * Create a payload for the `swap` transaction.\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)\n   * @param {Address | string} params.askJettonWalletAddress - Jetton router's wallet address of tokens to be received\n   * @param {Address | string | undefined} params.referralAddress - Optional; referral address\n   *\n   * @returns {Cell} payload for the `swap` transaction.\n   */\n  public async createSwapBody(params: {\n    userWalletAddress: AddressType;\n    minAskAmount: AmountType;\n    askJettonWalletAddress: AddressType;\n    referralAddress?: AddressType;\n  }): Promise<Cell> {\n    return this.revision.createSwapBody(this, params);\n  }\n\n  /**\n   * Create a payload for the `provide_lp` transaction.\n   *\n   * @param {Address | string} params.routerWalletAddress - Address of the router's Jetton token wallet\n   * @param {BN | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)\n   *\n   * @returns payload for the `provide_lp` transaction.\n   */\n  public async createProvideLiquidityBody(params: {\n    routerWalletAddress: AddressType;\n    minLpOut: AmountType;\n  }): Promise<Cell> {\n    return this.revision.createProvideLiquidityBody(this, params);\n  }\n\n  /**\n   * **Note:** It's necessary to specify addresses of Jetton wallets of the router as the arguments of this method.\n   * These addresses can be retrieved with getJettonWalletAddress of the Jetton minter.\n   * @param {Address | string} params.token0 - The address of the router's wallet of first Jetton\n   * @param {Address | string} params.token1 - The address of the router's wallet of second Jetton\n   *\n   * @returns {Address | null} an address of a pool for a specified pair of assets.\n   */\n  public async getPoolAddress(params: {\n    token0: AddressType;\n    token1: AddressType;\n  }): Promise<Address | null> {\n    return this.revision.getPoolAddress(this, params);\n  }\n\n  /**\n   * @param {[Address | string, Address | string]} params.jettonAddresses - Tuple of Jetton addresses of a pool\n   *\n   * @returns {Pool} object for a pool with specified Jetton token addresses.\n   */\n  public async getPool(params: {\n    jettonAddresses: [AddressType, AddressType];\n  }): Promise<Pool | null> {\n    const jetton0 = new JettonMinter(\n      this.provider,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      {\n        address: params.jettonAddresses[0],\n      },\n    );\n\n    const jetton1 = new JettonMinter(\n      this.provider,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      {\n        address: params.jettonAddresses[1],\n      },\n    );\n\n    const routerAddress = await this.getAddress();\n    const jetton0WalletAddress = await jetton0.getJettonWalletAddress(\n      routerAddress,\n    );\n    const jetton1WalletAddress = await jetton1.getJettonWalletAddress(\n      routerAddress,\n    );\n\n    const poolAddress = await this.getPoolAddress({\n      token0: jetton0WalletAddress,\n      token1: jetton1WalletAddress,\n    });\n\n    if (!poolAddress) return null;\n\n    return new Pool(\n      this.provider,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      {\n        address: poolAddress,\n        revision: this.revision.constructPoolRevision(this),\n      },\n    );\n  }\n\n  /**\n   * @returns {RouterData} containing current state of the router.\n   */\n  public async getData(): Promise<RouterData> {\n    return await this.revision.getData(this);\n  }\n\n  /**\n   * Build all data required to execute a jetton `swap` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.offerJettonAddress - Jetton address of a token to be swapped\n   * @param {Address | string} params.askJettonAddress - Jetton address of a token to be received\n   * @param {BN | number} params.offerAmount - Amount of tokens to be swapped (in basic token units)\n   * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)\n   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)\n   * @param {BN | number | undefined} params.forwardGasAmount - Optional; forward amount of gas for the next transaction (in nanoTons)\n   * @param {Address | string | undefined} params.referralAddress - Optional; referral address\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} data required to execute a jetton `swap` transaction\n   */\n  public async buildSwapJettonTxParams(params: {\n    userWalletAddress: AddressType;\n    offerJettonAddress: AddressType;\n    askJettonAddress: AddressType;\n    offerAmount: AmountType;\n    minAskAmount: AmountType;\n    gasAmount?: AmountType;\n    forwardGasAmount?: AmountType;\n    referralAddress?: AddressType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const offerJetton = new JettonMinter(\n      this.provider,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      {\n        address: params.offerJettonAddress,\n      },\n    );\n\n    const askJetton = new JettonMinter(\n      this.provider,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      {\n        address: params.askJettonAddress,\n      },\n    );\n\n    const offerJettonWalletAddress = await offerJetton.getJettonWalletAddress(\n      new Address(params.userWalletAddress),\n    );\n    const askJettonWalletAddress = await askJetton.getJettonWalletAddress(\n      await this.getAddress(),\n    );\n\n    const forwardPayload = await this.createSwapBody({\n      userWalletAddress: params.userWalletAddress,\n      minAskAmount: params.minAskAmount,\n      askJettonWalletAddress: askJettonWalletAddress,\n      referralAddress: params.referralAddress,\n    });\n\n    const forwardTonAmount = new BN(\n      params.forwardGasAmount ?? this.gasConstants.swapForward,\n    );\n\n    const payload = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.offerAmount,\n      destination: await this.getAddress(),\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const gasAmount = new BN(params.gasAmount ?? this.gasConstants.swap);\n\n    return {\n      to: offerJettonWalletAddress,\n      payload,\n      gasAmount,\n    };\n  }\n\n  /**\n   * Build all data required to execute a ton to jetton `swap` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.proxyTonAddress - Address of a proxy ton contract\n   * @param {Address | string} params.askJettonAddress - Jetton address of a token to be received\n   * @param {BN | number} params.offerAmount - Amount of ton to be swapped (in nanoTons)\n   * @param {BN | number} params.minAskAmount - Minimum amount of tokens received (in basic token units)\n   * @param {BN | number | undefined} params.forwardGasAmount - Optional; forward amount of gas for the next transaction (in nanoTons)\n   * @param {Address | string | undefined} params.referralAddress - Optional; referral address\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} data required to execute a ton to jetton `swap` transaction\n   */\n  public async buildSwapProxyTonTxParams(params: {\n    userWalletAddress: AddressType;\n    proxyTonAddress: AddressType;\n    askJettonAddress: AddressType;\n    offerAmount: AmountType;\n    minAskAmount: AmountType;\n    forwardGasAmount?: AmountType;\n    referralAddress?: AddressType | undefined;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const proxyTonMinter = new JettonMinter(\n      this.provider,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      {\n        address: params.proxyTonAddress,\n      },\n    );\n\n    const askJettonMinter = new JettonMinter(\n      this.provider,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      {\n        address: params.askJettonAddress,\n      },\n    );\n\n    const proxyTonWalletAddress = await proxyTonMinter.getJettonWalletAddress(\n      await this.getAddress(),\n    );\n    const askJettonWalletAddress = await askJettonMinter.getJettonWalletAddress(\n      await this.getAddress(),\n    );\n\n    const forwardPayload = await this.createSwapBody({\n      userWalletAddress: params.userWalletAddress,\n      minAskAmount: params.minAskAmount,\n      askJettonWalletAddress: askJettonWalletAddress,\n      referralAddress: params.referralAddress,\n    });\n\n    const forwardTonAmount = new BN(\n      params.forwardGasAmount ?? this.gasConstants.swapForward,\n    );\n\n    const payload = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.offerAmount,\n      destination: await this.getAddress(),\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const gasAmount = new BN(params.offerAmount).add(forwardTonAmount);\n\n    return {\n      to: proxyTonWalletAddress,\n      payload,\n      gasAmount,\n    };\n  }\n\n  /**\n   * Collect all data required to execute a jetton `provide_lp` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.sendTokenAddress - Address of the provided Jetton token\n   * @param {Address | string} params.otherTokenAddress - Address of the other Jetton token in pair\n   * @param {BN | number} params.sendAmount - Amount of the first token deposited as liquidity (in basic token units)\n   * @param {BN | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)\n   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)\n   * @param {BN | number | undefined} params.forwardGasAmount - Optional; forward amount of gas for the next transaction (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} data required to execute a jetton `provide_lp` transaction\n   */\n  public async buildProvideLiquidityJettonTxParams(params: {\n    userWalletAddress: AddressType;\n    sendTokenAddress: AddressType;\n    otherTokenAddress: AddressType;\n    sendAmount: AmountType;\n    minLpOut: AmountType;\n    gasAmount?: AmountType;\n    forwardGasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const sendJettonMinter = new JettonMinter(\n      this.provider,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      {\n        address: params.sendTokenAddress,\n      },\n    );\n\n    const otherJettonMinter = new JettonMinter(\n      this.provider,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      {\n        address: params.otherTokenAddress,\n      },\n    );\n\n    const jettonWalletAddress = await sendJettonMinter.getJettonWalletAddress(\n      new Address(params.userWalletAddress),\n    );\n    const routerWalletAddress = await otherJettonMinter.getJettonWalletAddress(\n      await this.getAddress(),\n    );\n\n    const forwardPayload = await this.createProvideLiquidityBody({\n      routerWalletAddress: routerWalletAddress,\n      minLpOut: params.minLpOut,\n    });\n\n    const forwardTonAmount = new BN(\n      params.forwardGasAmount ?? this.gasConstants.provideLpForward,\n    );\n\n    const payload = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.sendAmount,\n      destination: await this.getAddress(),\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const gasAmount = new BN(params.gasAmount ?? this.gasConstants.provideLp);\n\n    return {\n      to: jettonWalletAddress,\n      payload,\n      gasAmount,\n    };\n  }\n\n  /**\n   * Collect all data required to execute a proxy ton `provide_lp` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.proxyTonAddress - Address of a proxy ton contract\n   * @param {Address | string} params.otherTokenAddress - Address of the other Jetton token in pair\n   * @param {BN | number} params.sendAmount - Amount of ton deposited as liquidity (in nanoTons)\n   * @param {BN | number} params.minLpOut - Minimum amount of created liquidity tokens (in basic token units)\n   * @param {BN | number | undefined} params.forwardGasAmount - Optional; forward amount of gas for the next transaction (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} data required to execute a proxy ton `provide_lp` transaction\n   */\n  public async buildProvideLiquidityProxyTonTxParams(params: {\n    userWalletAddress: AddressType;\n    proxyTonAddress: AddressType;\n    otherTokenAddress: AddressType;\n    sendAmount: AmountType;\n    minLpOut: AmountType;\n    forwardGasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const tonProxyMinter = new JettonMinter(\n      this.provider,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      {\n        address: params.proxyTonAddress,\n      },\n    );\n\n    const otherJettonMinter = new JettonMinter(\n      this.provider,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      {\n        address: params.otherTokenAddress,\n      },\n    );\n\n    const proxyTonWalletAddress = await tonProxyMinter.getJettonWalletAddress(\n      await this.getAddress(),\n    );\n    const routerWalletAddress = await otherJettonMinter.getJettonWalletAddress(\n      await this.getAddress(),\n    );\n\n    const forwardPayload = await this.createProvideLiquidityBody({\n      routerWalletAddress: routerWalletAddress,\n      minLpOut: params.minLpOut,\n    });\n\n    const forwardTonAmount = new BN(\n      params.forwardGasAmount ?? this.gasConstants.provideLp,\n    );\n\n    const payload = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.sendAmount,\n      destination: await this.getAddress(),\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const gasAmount = new BN(params.sendAmount).add(forwardTonAmount);\n\n    return {\n      to: proxyTonWalletAddress,\n      payload,\n      gasAmount,\n    };\n  }\n}\n","export const FARM_OP_CODES = {\n  STAKE: 0x6ec9dc65,\n  CLAIM_REWARDS: 0x78d9f109,\n  UNSTAKE: 0xb92965a0,\n} as const;\n\nexport const FARM_REVISION = {\n  V2: 'V2',\n} as const;\n","import type { Cell } from '@/types';\n\nexport function parseString(cell: Cell) {\n  const decoder = new TextDecoder();\n  return decoder.decode(cell.bits.getTopUppedArray());\n}\n","import TonWeb from 'tonweb';\n\nimport type { Cell, BN } from '@/types';\nimport { FARM_OP_CODES } from '../constants';\nimport { parseAddress } from '@/utils/parseAddress';\nimport { parseBoolean } from '@/utils/parseBoolean';\nimport { parseString } from '@/utils/parseString';\n\nimport type { FarmNftMinterRevision } from './FarmNftMinterRevision';\n\nconst {\n  utils: { BN },\n  boc: { Cell },\n} = TonWeb;\n\nexport class FarmNftMinterRevisionV2 implements FarmNftMinterRevision {\n  public get gasConstants(): FarmNftMinterRevision['gasConstants'] {\n    return {\n      stake: new BN(300000000),\n      stakeForward: new BN(250000000),\n    };\n  }\n\n  public createStakeBody: FarmNftMinterRevision['createStakeBody'] = async (\n    _minter,\n  ) => {\n    const payload = new Cell();\n\n    payload.bits.writeUint(FARM_OP_CODES.STAKE, 32);\n\n    return payload;\n  };\n\n  public getPendingData: FarmNftMinterRevision['getPendingData'] = async (\n    minter,\n  ) => {\n    const contractAddress = await minter.getAddress();\n\n    const result = await minter.provider.call2(\n      contractAddress.toString(),\n      'get_pending_data',\n    );\n\n    return {\n      changeCustodianTs: result[0] as BN,\n      sendMsgTs: result[1] as BN,\n      codeUpgradeTs: result[2] as BN,\n      newCustodian: parseAddress(result[3]),\n      pendingMsg: result[4] as Cell,\n      newCode: result[5] as Cell,\n      newStorage: result[6] as Cell,\n    };\n  };\n\n  public getVersion: FarmNftMinterRevision['getVersion'] = async (minter) => {\n    const contractAddress = await minter.getAddress();\n\n    const result = await minter.provider.call2(\n      contractAddress.toString(),\n      'get_version',\n    );\n\n    return {\n      major: result[0] as number,\n      minor: result[1] as number,\n      development: parseString(result[2]),\n    };\n  };\n\n  public getData: FarmNftMinterRevision['getData'] = async (minter) => {\n    const contractAddress = await minter.getAddress();\n\n    const result = await minter.provider.call2(\n      contractAddress.toString(),\n      'get_farming_minter_data',\n    );\n\n    const stakingTokenWallet = parseAddress(result[14]);\n\n    if (!stakingTokenWallet) {\n      throw new Error(\n        `Failed to parse stakingTokenWallet from cell: ${result[14]}`,\n      );\n    }\n\n    const rewardTokenWallet = parseAddress(result[15]);\n\n    if (!rewardTokenWallet) {\n      throw new Error(\n        `Failed to parse rewardTokenWallet from cell: ${result[15]}`,\n      );\n    }\n\n    return {\n      nextItemIndex: result[0] as BN,\n      lastUpdateTime: result[1] as BN,\n      status: result[2] as number,\n      depositedNanorewards: result[3] as BN,\n      currentStakedTokens: result[4] as BN,\n      accruedPerUnitNanorewards: result[5] as BN,\n      claimedFeeNanorewards: result[6] as BN,\n      accruedFeeNanorewards: result[7] as BN,\n      accruedNanorewards: result[8] as BN,\n      claimedNanorewards: result[9] as BN,\n      contractUniqueId: result[10] as BN,\n      nanorewardsPer24h: result[11] as BN,\n      adminFee: result[12] as BN,\n      minStakeTime: result[13] as BN,\n      stakingTokenWallet,\n      rewardTokenWallet,\n      custodianAddress: parseAddress(result[16]),\n      canChangeCustodian: parseBoolean(result[17]),\n      canSendRawMsg: parseBoolean(result[18]),\n      canChangeFee: parseBoolean(result[19]),\n      unrestrictedDepositRewards: parseBoolean(result[20]),\n\n      // NFTs are always soulbound in V2\n      soulboundItems: true,\n    };\n  };\n}\n","import TonWeb from 'tonweb';\n\nimport type {\n  Address,\n  Cell,\n  HttpProvider,\n  BN,\n  AddressType,\n  QueryIdType,\n  MessageData,\n  AmountType,\n  NftCollectionOptions,\n} from '@/types';\nimport { FARM_REVISION } from '../constants';\nimport { createJettonTransferMessage } from '@/utils/createJettonTransferMessage';\n\nimport type { FarmNftMinterRevision } from './FarmNftMinterRevision';\nimport { FarmNftMinterRevisionV2 } from './FarmNftMinterRevisionV2';\n\nconst {\n  Address,\n  utils: { BN },\n  token: {\n    nft: { NftCollection },\n    jetton: { JettonMinter, JettonWallet },\n  },\n} = TonWeb;\n\nconst REVISIONS = {\n  [FARM_REVISION.V2]: FarmNftMinterRevisionV2,\n} as const;\n\nexport type FarmNftMinterGasConstants = {\n  stake: BN;\n  stakeForward: BN;\n};\n\n/**\n * @typedef {Object} FarmNftMinterData\n *\n * @property {BN} nextItemIndex - Index of the next nft in this collection\n * @property {BN} lastUpdateTime - Last time farming values were updated\n * @property {number} status - Status of the contract: uninitialized `0`, active `1`, paused `3`\n * @property {BN} depositedNanorewards - Deposited rewards in nanounits\n * @property {BN} currentStakedTokens - Number of staked tokens in basic token units\n * @property {BN} accruedPerUnitNanorewards - Number of accrued nanorewards per basic stake token unit\n * @property {BN} claimedFeeNanorewards - Claimed fees @since V2 revision\n * @property {BN} accruedFeeNanorewards - Accrued fees @since V2 revision\n * @property {BN} accruedNanorewards - Total number of accrued rewards in nanounits\n * @property {BN} claimedNanorewards - Number of claimed rewards in nanounits\n * @property {BN} contractUniqueId - Minter id\n * @property {BN} nanorewardsPer24h - Total number of accrued rewards per 24h in nanounits\n * @property {BN} adminFee - Admin fee; divider is 10000 @since V2 revision\n * @property {Boolean} soulboundItems - Whether minted NFTs are soulbound\n * @property {BN} minStakeTime - Minimum staking time\n * @property {Address} stakingTokenWallet - Minter's staking jetton wallet\n * @property {Address} rewardTokenWallet - Minter's reward jetton wallet\n * @property {Address} custodianAddress - Custodian address @since V2 revision\n * @property {Boolean} canChangeCustodian - If can change custodian @since V2 revision\n * @property {Boolean} canSendRawMsg - If can send raw msg @since V2 revision\n * @property {Boolean} canChangeFee - If can change fee @since V2 revision\n * @property {Boolean} unrestrictedDepositRewards - If rewards can be deposited by anyone @since V2 revision\n */\nexport type FarmNftMinterData = {\n  nextItemIndex: BN;\n  lastUpdateTime: BN;\n  status: number;\n  depositedNanorewards: BN;\n  currentStakedTokens: BN;\n  accruedPerUnitNanorewards: BN;\n  claimedFeeNanorewards: BN;\n  accruedFeeNanorewards: BN;\n  accruedNanorewards: BN;\n  claimedNanorewards: BN;\n  contractUniqueId: BN;\n  nanorewardsPer24h: BN;\n  adminFee: BN;\n  soulboundItems: Boolean;\n  minStakeTime: BN;\n  stakingTokenWallet: Address;\n  rewardTokenWallet: Address;\n  custodianAddress: Address | null;\n  canChangeCustodian: Boolean;\n  canSendRawMsg: Boolean;\n  canChangeFee: Boolean;\n  unrestrictedDepositRewards: Boolean;\n};\n\n/**\n * @since V2 revision\n * @typedef {Object} PendingData\n *\n * @property {BN} changeCustodianTs - Timestamp when 'change_custodian' was initiated\n * @property {BN} sendMsgTs - Timestamp when 'send_raw_msg' was initiated\n * @property {BN} codeUpgradeTs - Timestamp when 'code_upgrade' was initiated\n * @property {Address} newCustodian - New custodian that will be set after confirmation\n * @property {Cell} pendingMsg - Pending msg that will be sends after confirmation\n * @property {Cell} newCode - New contract code that will be set after confirmation\n * @property {Cell} newStorage - New contract storage that will be set after confirmation\n */\nexport type PendingData = {\n  changeCustodianTs: BN;\n  sendMsgTs: BN;\n  codeUpgradeTs: BN;\n  newCustodian: Address | null;\n  pendingMsg: Cell;\n  newCode: Cell;\n  newStorage: Cell;\n};\n\n/**\n * @since V2 revision\n * @typedef {Object} Version\n *\n * @property {number} major - Major version; breaking changes in api\n * @property {number} minor - Minor version; non-breaking new functionality\n * @property {string} development - Development version; can contain breaking changes\n */\nexport type Version = {\n  major: number;\n  minor: number;\n  development: string;\n};\n\ninterface FarmNftMinterOptions extends NftCollectionOptions {\n  revision: FarmNftMinterRevision | keyof typeof REVISIONS;\n  address: AddressType;\n}\n\nexport class FarmNftMinter extends NftCollection {\n  private revision: FarmNftMinterRevision;\n\n  constructor(\n    provider: HttpProvider,\n    { revision, ...options }: FarmNftMinterOptions,\n  ) {\n    super(provider, options);\n\n    if (typeof revision === 'string') {\n      if (!REVISIONS[revision])\n        throw Error(`Unknown pool revision: ${revision}`);\n\n      this.revision = new REVISIONS[revision]();\n    } else {\n      this.revision = revision;\n    }\n  }\n\n  public get gasConstants(): FarmNftMinterGasConstants {\n    return this.revision.gasConstants;\n  }\n\n  /**\n   * Create a payload for the `stake` transaction.\n   *\n   * @returns payload for the `stake` transaction.\n   */\n  public async createStakeBody(): Promise<Cell> {\n    return this.revision.createStakeBody(this);\n  }\n\n  /**\n   * @returns {Address} address of minter for staking jetton\n   */\n  public async getStakingJettonAddress(): Promise<Address> {\n    const { stakingTokenWallet } = await this.getData();\n\n    const jettonWallet = new JettonWallet(\n      this.provider,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      {\n        address: stakingTokenWallet,\n      },\n    );\n\n    const { jettonMinterAddress } = await jettonWallet.getData();\n\n    return jettonMinterAddress;\n  }\n\n  public async getPendingData(): Promise<PendingData> {\n    return this.revision.getPendingData(this);\n  }\n\n  public async getVersion(): Promise<Version> {\n    return this.revision.getVersion(this);\n  }\n\n  /**\n   * @returns {FarmNftMinterData} containing current state of the minter\n   */\n  public async getData(): Promise<FarmNftMinterData> {\n    return this.revision.getData(this);\n  }\n\n  /**\n   * Build all data required to execute a jetton `stake` transaction\n   *\n   * @param {Address | string} params.userWalletAddress - User's address\n   * @param {Address | string} params.jettonAddress - Jetton address of token to be staked\n   * @param {BN | number} params.jettonAmount - Amount of tokens to be staked (in basic token units)\n   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)\n   * @param {BN | number | undefined} params.forwardGasAmount - Optional; forward amount of gas for the next transaction (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} containing all data required to execute a jetton `stake` transaction\n   */\n  public async buildStakeTxParams(params: {\n    userWalletAddress: AddressType;\n    jettonAddress: AddressType;\n    jettonAmount: AmountType;\n    gasAmount?: AmountType;\n    forwardGasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const jetton = new JettonMinter(\n      this.provider,\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      {\n        address: params.jettonAddress,\n      },\n    );\n\n    const jettonWalletAddress = await jetton.getJettonWalletAddress(\n      new Address(params.userWalletAddress),\n    );\n\n    const forwardPayload = await this.createStakeBody();\n\n    const forwardTonAmount = new BN(\n      params.forwardGasAmount ?? this.gasConstants.stakeForward,\n    );\n\n    const payload = createJettonTransferMessage({\n      queryId: params.queryId ?? 0,\n      amount: params.jettonAmount,\n      destination: await this.getAddress(),\n      responseDestination: params.userWalletAddress,\n      forwardTonAmount,\n      forwardPayload,\n    });\n\n    const gasAmount = new BN(params.gasAmount ?? this.gasConstants.stake);\n\n    return {\n      to: jettonWalletAddress,\n      payload,\n      gasAmount,\n    };\n  }\n}\n","import TonWeb from 'tonweb';\n\nimport type { QueryIdType, Cell } from '@/types';\n\nconst {\n  boc: { Cell },\n} = TonWeb;\n\n/**\n * Implements `destroy` function from SBT Standard.\n * [Docs](https://github.com/ton-blockchain/TEPs/blob/master/text/0085-sbt-standard.md#3-destroy)\n *\n * ```TL-B\n * destroy#1f04537a query_id:uint64 = InternalMsgBody;\n * ```\n */\nexport function createSbtDestroyMessage(params?: { queryId: QueryIdType }) {\n  const message = new Cell();\n\n  message.bits.writeUint(0x1f04537a, 32);\n  message.bits.writeUint(params?.queryId ?? 0, 64);\n\n  return message;\n}\n","import TonWeb from 'tonweb';\n\nimport { FARM_OP_CODES } from '../constants';\nimport type { Cell, BN } from '@/types';\nimport { createSbtDestroyMessage } from '@/utils/createSbtDestroyMessage';\n\nimport type { FarmNftItemRevision } from './FarmNftItemRevision';\n\nconst {\n  utils: { BN },\n  boc: { Cell },\n} = TonWeb;\n\nexport class FarmNftItemRevisionV2 implements FarmNftItemRevision {\n  public get gasConstants(): FarmNftItemRevision['gasConstants'] {\n    return {\n      claimRewards: new BN(300000000),\n      unstake: new BN(400000000),\n      destroy: new BN(50000000),\n    };\n  }\n\n  public createClaimRewardsBody: FarmNftItemRevision['createClaimRewardsBody'] =\n    async (_nft, params) => {\n      const message = new Cell();\n\n      message.bits.writeUint(FARM_OP_CODES.CLAIM_REWARDS, 32);\n      message.bits.writeUint(params?.queryId ?? 0, 64);\n\n      return message;\n    };\n\n  public createUnstakeBody: FarmNftItemRevision['createUnstakeBody'] = async (\n    _nft,\n    params,\n  ) => {\n    const message = new Cell();\n\n    message.bits.writeUint(FARM_OP_CODES.UNSTAKE, 32);\n    message.bits.writeUint(params?.queryId ?? 0, 64);\n\n    return message;\n  };\n\n  public createDestroyBody: FarmNftItemRevision['createDestroyBody'] = async (\n    _nft,\n    params,\n  ) => {\n    return createSbtDestroyMessage({\n      queryId: params?.queryId ?? 0,\n    });\n  };\n\n  public getFarmingData: FarmNftItemRevision['getFarmingData'] = async (\n    nft,\n  ) => {\n    const contractAddress = await nft.getAddress();\n\n    const result = await nft.provider.call2(\n      contractAddress.toString(),\n      'get_farming_data',\n    );\n\n    return {\n      status: result[0] as number,\n      revokeTime: result[1] as BN,\n      stakedTokens: result[2] as BN,\n      claimedPerUnitNanorewards: result[3] as BN,\n      stakeDate: result[4] as BN,\n\n      // NFTs are always soulbound in V2\n      isSoulbound: true,\n    };\n  };\n}\n","import TonWeb from 'tonweb';\n\nimport type {\n  Cell,\n  HttpProvider,\n  BN,\n  AddressType,\n  QueryIdType,\n  MessageData,\n  AmountType,\n  NftItemOptions,\n} from '@/types';\nimport { FARM_REVISION } from '../constants';\n\nimport { FarmNftItemRevision } from './FarmNftItemRevision';\nimport { FarmNftItemRevisionV2 } from './FarmNftItemRevisionV2';\n\nconst {\n  utils: { BN },\n  token: {\n    nft: { NftItem },\n  },\n} = TonWeb;\n\nconst REVISIONS = {\n  [FARM_REVISION.V2]: FarmNftItemRevisionV2,\n} as const;\n\nexport type FarmNftItemGasConstants = {\n  claimRewards: BN;\n  unstake: BN;\n  destroy: BN;\n};\n\n/**\n * @type {FarmNftItemFarmingData} represent state of the farm NFT\n *\n * @property {number} status Status of the contract: uninitialized `0`, active `1`, unstaked `2`, claiming `3`\n * @property {boolean} isSoulbound If nft is soulbound\n * @property {BN} revokeTime Timestamp of unstake @since V2 revision\n * @property {BN} stakedTokens Amount of staked tokens\n * @property {BN} claimedPerUnitNanorewards `accrued_per_unit_nanorewards` at the time the user made the stake or last claimed rewards\n * @property {BN} stakeDate Timestamp in which the owner started staking\n */\nexport type FarmNftItemFarmingData = {\n  status: number;\n  isSoulbound: boolean;\n  revokeTime: BN;\n  stakedTokens: BN;\n  claimedPerUnitNanorewards: BN;\n  stakeDate: BN;\n};\n\ninterface FarmNftItemOptions extends NftItemOptions {\n  revision: FarmNftItemRevision | keyof typeof REVISIONS;\n  address: AddressType;\n}\n\nexport class FarmNftItem extends NftItem {\n  private revision: FarmNftItemRevision;\n\n  constructor(\n    provider: HttpProvider,\n    { revision, ...options }: FarmNftItemOptions,\n  ) {\n    super(provider, options);\n\n    if (typeof revision === 'string') {\n      if (!REVISIONS[revision])\n        throw Error(`Unknown farm NFT item revision: ${revision}`);\n\n      this.revision = new REVISIONS[revision]();\n    } else {\n      this.revision = revision;\n    }\n  }\n\n  public get gasConstants(): FarmNftItemGasConstants {\n    return this.revision.gasConstants;\n  }\n\n  /**\n   * Creates payload for the `claim_rewards` transaction.\n   *\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {Cell} payload for the `claim_rewards` transaction.\n   */\n  public async createClaimRewardsBody(params: {\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    return this.revision.createClaimRewardsBody(this, params);\n  }\n\n  /**\n   * Creates payload for the `destroy` transaction.\n   *\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {Cell} payload for the `destroy` transaction.\n   */\n  public async createDestroyBody(params: {\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    return this.revision.createDestroyBody(this, params);\n  }\n\n  /**\n   * Creates payload for the `unstake` transaction.\n   *\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {Cell} payload for the `unstake` transaction.\n   */\n  public async createUnstakeBody(params: {\n    queryId?: QueryIdType;\n  }): Promise<Cell> {\n    return this.revision.createUnstakeBody(this, params);\n  }\n\n  /**\n   * @returns {FarmNftItemFarmingData} structure containing current state of the farm NFT\n   */\n  public async getFarmingData(): Promise<FarmNftItemFarmingData> {\n    return await this.revision.getFarmingData(this);\n  }\n\n  /**\n   * Build all data required to execute a `claim_rewards` transaction.\n   *\n   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} all data required to execute a `claim_rewards` transaction.\n   */\n  public async buildClaimRewardsTxParams(params?: {\n    gasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const to = await this.getAddress();\n\n    const payload = await this.createClaimRewardsBody({\n      queryId: params?.queryId,\n    });\n\n    const gasAmount = new BN(\n      params?.gasAmount ?? this.gasConstants.claimRewards,\n    );\n\n    return { to, payload, gasAmount };\n  }\n\n  /**\n   * Build all data required to execute a `unstake` transaction.\n   *\n   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} all data required to execute a `unstake` transaction.\n   */\n  public async buildUnstakeTxParams(params?: {\n    gasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const to = await this.getAddress();\n\n    const payload = await this.createUnstakeBody({ queryId: params?.queryId });\n\n    const gasAmount = new BN(params?.gasAmount ?? this.gasConstants.unstake);\n\n    return { to, payload, gasAmount };\n  }\n\n  /**\n   * Build all data required to execute a `destroy` transaction.\n   *\n   * @param {BN | number | undefined} params.gasAmount - Optional; amount of gas for the transaction (in nanoTons)\n   * @param {BN | number | undefined} params.queryId - Optional; query id\n   *\n   * @returns {MessageData} all data required to execute a `destroy` transaction.\n   */\n  public async buildDestroyTxParams(params?: {\n    gasAmount?: AmountType;\n    queryId?: QueryIdType;\n  }): Promise<MessageData> {\n    const to = await this.getAddress();\n\n    const payload = await this.createDestroyBody({ queryId: params?.queryId });\n\n    const gasAmount = new BN(params?.gasAmount ?? this.gasConstants.destroy);\n\n    return {\n      to,\n      payload,\n      gasAmount,\n    };\n  }\n}\n","export { createJettonTransferMessage } from './createJettonTransferMessage';\nexport { createSbtDestroyMessage } from './createSbtDestroyMessage';\nexport { parseAddress } from './parseAddress';\nexport { parseBoolean } from './parseBoolean';\nexport { parseString } from './parseString';\n\nimport { parseAddress } from './parseAddress';\n\n/** @deprecated Use `parseAddress` instead. */\nexport const parseAddressFromCell = parseAddress;\n"],"names":["DEX_OP_CODES","ROUTER_REVISION","ROUTER_REVISION_ADDRESS","Address","TonWeb","readIntFromBitString","bs","cursor","bits","n","i","parseAddress","cell","hashPart","s","Cell","BN","LpAccountRevisionV1","_lpAccount","params","message","lpAccount","contractAddress","result","Contract","REVISIONS","LpAccount","provider","revision","options","to","payload","gasAmount","bytesToBase64","PoolRevisionV1","_pool","pool","slice","poolAddress","JettonMinter","JettonWallet","Pool","poolWalletAddress","accountAddress","createJettonTransferMessage","parseBoolean","bn","RouterRevisionV1","_router","router","cellA","cellB","sliceA","sliceB","routerAddress","Router","jetton0","jetton1","jetton0WalletAddress","jetton1WalletAddress","offerJetton","askJetton","offerJettonWalletAddress","askJettonWalletAddress","forwardPayload","forwardTonAmount","proxyTonMinter","askJettonMinter","proxyTonWalletAddress","sendJettonMinter","otherJettonMinter","jettonWalletAddress","routerWalletAddress","tonProxyMinter","FARM_OP_CODES","FARM_REVISION","parseString","FarmNftMinterRevisionV2","_minter","minter","stakingTokenWallet","rewardTokenWallet","NftCollection","FarmNftMinter","jettonWallet","jettonMinterAddress","createSbtDestroyMessage","FarmNftItemRevisionV2","_nft","nft","NftItem","FarmNftItem","parseAddressFromCell"],"mappings":"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"}